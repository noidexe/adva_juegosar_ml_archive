{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"WELCOME_MSG"}]},{"resourceType":"PHOTO","capabilities":[{"name":"READ"},{"name":"UPLOAD"},{"name":"UPLOADTEMP"}]},{"resourceType":"FILE","capabilities":[{"name":"READ"},{"name":"CREATE"}]},{"resourceType":"MEMBER","capabilities":[{"name":"READ"}]},{"resourceType":"LINK","capabilities":[{"name":"CREATE"},{"name":"READ"}]},{"resourceType":"CALENDAR","capabilities":[{"name":"READ"}]},{"resourceType":"DATABASE","capabilities":[{"name":"CREATE"},{"name":"READ"},{"name":"READ_DATA"}]},{"resourceType":"POLL","capabilities":[{"name":"READ"},{"name":"VOTE"},{"name":"CREATE"}]},{"resourceType":"MESSAGE","capabilities":[{"name":"CREATE"},{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[{"name":"READ"},{"name":"UPLOAD"}]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[{"name":"READ"}]},{"resourceType":"POST","capabilities":[{"name":"CREATE"},{"name":"READ"}]},{"resourceType":"PIN","capabilities":[{"name":"CREATE"},{"name":"DELETE"},{"name":"READ"},{"name":"UPDATE"}]}],"subStatus":"NORMAL","groupUrl":"ar.groups.yahoo.com","intlCode":"ar"},"comscore":"pageview_candidate","ygData":{"userId":112566267,"authorName":"Nahuel Greco","from":"Nahuel Greco &lt;nahu@...&gt;","replyTo":"LIST","senderId":"TyWsWmCnYDo6xmDyxmANjVwDM8uJ6Tfr0itm_jz99YzgpExXmXxqShFeHsEu_UFaJqeiyeGgZ7K5SWrw-sK9fs30s6UuTBM","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [ADVA] RE: interfases adaptables din\u0010","postDate":"1030340327","msgId":5346,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMDIwODI2MDIzODQ3LjM5OTc0M2ZlLm5haHVAc29mdGhvbWUubmV0Pg==","inReplyToHeader":"PDAwMWEwMWMyNGNiZCQzOTRlZjE0MCQ2OTEwMjljOEBNSUNST1NPRlQ+","referencesHeader":"PDIwMDIwODE3MDIzOTExLjYyNzMucW1haWxAd2ViMTQ0MTAubWFpbC55YWhvby5jb20+CTxPRTUzQzRvbjBZa0tsTUpyMG5TMDAwMDU3MWNAaG90bWFpbC5jb20+CTwyMDAyMDgyMTAyMDIxMy40NmEzMjUwZC5uYWh1QHNvZnRob21lLm5ldD4JPDAwMWEwMWMyNGNiZCQzOTRlZjE0MCQ2OTEwMjljOEBNSUNST1NPRlQ+"},"prevInTopic":5340,"nextInTopic":5356,"prevInTime":5345,"nextInTime":5347,"topicId":5340,"numMessagesInTopic":3,"msgSnippet":"On Sun, 25 Aug 2002 21:56:45 -0700 ... No le des demasiada bola a Carmack en lo relativo a arquitectura de Software (en gral), es mejor en ese campo leer a","rawEmail":"Return-Path: &lt;nahu@...&gt;\r\nX-Sender: nahu@...\r\nX-Apparently-To: JuegosAR@...\r\nReceived: (EGP: mail-8_1_0_1); 26 Aug 2002 05:38:44 -0000\r\nReceived: (qmail 55787 invoked from network); 26 Aug 2002 05:38:44 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m9.grp.scd.yahoo.com with QMQP; 26 Aug 2002 05:38:44 -0000\r\nReceived: from unknown (HELO www.codelarvs.com.ar) (200.63.161.125)\n  by mta3.grp.scd.yahoo.com with SMTP; 26 Aug 2002 05:38:41 -0000\r\nReceived: from darwin (darwin [192.168.1.1])\n\tby www.codelarvs.com.ar (Postfix) with SMTP id 0A62E1C5822\n\tfor &lt;JuegosAR@...&gt;; Mon, 26 Aug 2002 02:38:48 -0300 (ART)\r\nDate: Mon, 26 Aug 2002 02:38:47 -0300\r\nTo: JuegosAR@...\r\nSubject: Re: [ADVA] RE: interfases adaptables din\u0010\r\nMessage-Id: &lt;20020826023847.399743fe.nahu@...&gt;\r\nIn-Reply-To: &lt;001a01c24cbd$394ef140$691029c8@MICROSOFT&gt;\r\nReferences: &lt;20020817023911.6273.qmail@...&gt;\n\t&lt;OE53C4on0YkKlMJr0nS0000571c@...&gt;\n\t&lt;20020821020213.46a3250d.nahu@...&gt;\n\t&lt;001a01c24cbd$394ef140$691029c8@MICROSOFT&gt;\r\nOrganization: Codenix\r\nX-Mailer: Sylpheed version 0.8.1 (GTK+ 1.2.10; i386-debian-linux-gnu)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 8bit\r\nFrom: Nahuel Greco &lt;nahu@...&gt;\r\nX-Yahoo-Group-Post: member; u=112566267\r\n\r\nOn Sun, 25 Aug 2002 21:56:45 -0700\n&quot;Ale Palmero&quot; &lt;apalmero@...&gt; wrote:\n\n&gt; A la vez termin� de leer Code complete y mi gran\n&gt; duda es si todo esto ( adaptadores entre componentes, proxies, delegacion,\n&gt; jerarquias din�micas ) se aplica a los juegos hoy dia.\n&gt; No hace mucho que Carmack predicaba en contra de c++ y que la herencia\n&gt; multiple por ejemplo era mala palabra.\n&gt; \n&gt; Segun parece, directx lo est� usando pero no termino de convencerme....\n&gt; \n\nNo le des demasiada bola a Carmack en lo relativo a arquitectura de Software\n(en gral), es mejor en ese campo leer a gente como Martin Fowler o Kent Beck.\nEsta bien criticar a C++, pero no tiene mucho sentido cuando la critica\napunta a idolatrar a C :)\n\n&lt;NIGHTLY-PRO-DYNAMIC-LANGUAGES-RANT&gt;\n\nCon respecto a tu gran duda, justamente, IMHO uno de los problemas para la\naplicaci�n de esas t�cnicas en games, es que los games se suelen hacer en C++,\ny C++ es a pain in the ass en la mayor�a de los casos (flames a mi!). Por\nejemplo, no es lo mismo hacer un Proxy asi:\n\n    class Casita {\n        int        num_paredes;\n        bool       made_of_chocolate;\n    public:\n        Casita()   { (...) }\n        ~Casita()  { (...) }\n        dibujar()  { (...) }\n\tromper()   { (...) }\n        hacerla_de_chocolate() { (...) }\n    };\n\n    // Notar que me tengo que tomar todo el trabajo de transcribir\n    // metodo por metodo en el proxy:\n    class ProxyACasita {\n        Casita *casita;\n    public:\n        Casita() { casita = new Casita(); } // inicializado aqui para\n                                            // simplificar\n        ~Casita() { delete casita; }\n        dibujar() {\n                    casita-&gt;dibujar()\n                    }\n        romper() {\n                    casita-&gt;romper()\n                    }\n        hacerla_de_chocolate() {\n                        casita-&gt;hacerla_de_chocolate()\n                    }\n    };\n\nQue hacerlo as� (python):\n\n    class Casita:\n        def __init__(self):\n            self.num_paredes = 2 \n            self.made_of_chocolate = 2\n        def dibujar(self):\n                print &quot;Dibujada&quot;\n        def romper(self):\n                (...)\n        def hacerla_de_chocolate:\n                (...)\n\n   class Autito:\n        def __init__(self):\n            (...)\n        def orientar(self, grados):\n                print &quot;Orientado&quot;\n                self.orientacion = grados\n\n# Ahora creo una clase Proxy --Generica--:\n\n    class DebugProxy:\n        def __init__(self,dest):\n            self.destinatario = dest\n        def __getattr__( self, mensaje):\n            # ejemplo de algo que podria hacer        \n            print mensaje,&quot;fue llamado&quot;\n            return getattr( self.destinatario, mensaje )  \n\nSo, luego puedo hacer:\n\n    &gt;&gt;&gt; una_casita_lejana = DebugProxy(Casita())\n    &gt;&gt;&gt; una_casita_lejana.dibujar() \n    dibujar fue llamado\n    Dibujada\n    &gt;&gt;&gt; auto = DebugProxy(Autito())\n    &gt;&gt;&gt; auto.orientar(3)\n    orientar fue llamado\n    Orientado\n    &gt;&gt;&gt;\n\nNot� que la clase &quot;DebugProxy&quot; es gen�rica, solo tuve que hacerla una vez\npara cualquier clase en la que la quiera aplicar. Tampoco tuve que tomarme\nel trabajo de copiar (ni mantener a trav�s de las versiones) toda la interfaz\nde la clase a la que le quiero proxy&#39;ear las instancias. La interfaz del\nproxy se adapta a cualquier m�todo nuevo que le agregue a Casita o Autito.\nNo es nada magico ni un caso especial, es natural de pensar que uno puede\ncrear un objeto que simplemente le tira todos los mensajes que le mandan\na �l a otro objeto. Que C++ no soporte naturalmente eso es problema de �l :)\n\nSiguiendo con esto, pensa en la dificultad inherente a C++ para usar Proxys con\nobjetos que son remotos (est�n en otra m�quina), y a los que no le conoces la\ninterfaz por adelantado. No es imposible, pero hay que laburarlo, y no te va a\nquedar elegante, cuando en un lenguaje din�mico no son m�s de 15 lineas de\ncode. So, son los limites del C++, COM+ es solo un intento por emparchar esos\ndownsides del lenguaje.\n\nObviamente, cuando codeemos C++, no porque sea m�s dif�cil/trabajoso vamos a\ndejar de &#39;aplicar&#39;, conscientemente o no, los design patterns. Design patterns\nque originalmente fueron pensados en Smalltalk para formalizar y dar un\nvocabulario a cosas que ya se ven�an haciendo (la implementaci�n de un Proxy en\nST es &#39;similar&#39; a la que puse anteriormente en py, en el sentido que es\n&#39;dinamica&#39;/natural). Usarlos en C++ es como intentar encastrar un cubo de\nhierro en un agujero cilindrico, pero hay que hacerlo aunque quede todo roto\ny feo. Mientras que con los lenguajes din�micos no tenemos un cilindro sino\nuna pelota, pero es de plastilina :)\n\nSo, de usar C++, IMHO hay que intentar minimizar su uso y aplicarlo solo para\nlowlevel, y arriba un lenguaje &#39;de scripting&#39;/dinamico.\n\nEn cuanto a la herencia m�ltiple, el problema conceptual t�pico con el que te\npodes encontrar es:\n\n     Humano\n     /    &#92; \n  Mujer    Hombre\n    &#92;       /\n   Hemafrodita\n\n(Nota, con H.M. el grafo de herencia se te puede complicar mucho m�s, este es\nun ejemplo simple, sin H.M. tenes la seguridad de que siempre es un tree)\n\nF�jate, seg�n ese gr�fico, tanto una Mujer como un Hombre son Humanos, el\nHemafrodita tambi�n lo es, pero en una instancia de Hemafrodita, tenemos que\nmantener una o dos instancias de Humano? en este caso se podr�a resolver\nmanteniendo una sola instancia, pero hay otros casos en donde tenemos que\nguardar dos instancias de la primera clase:\n\n            Empleado\n             /   &#92; \n          Mozo   Programador\n            &#92;     /\n    ArgentinoQueNoLlegaAFinDeMes\n\nEn este caso, Empleado podr�a tener una variable que sea &quot;lugar_de_trabajo&quot;,\nun Mozo tiene un lugar de trabajo y se lo setea al Empleado, lo mismo un\nProgramador a Sueldo, pero que pasa con el tipo que tiene dos laburos, el\nArgentinoQueNoLlegaAFinDeMes ? Si tiene una sola instancia de Empleado,\nentonces va a haber conflicto, en este caso se precisan dos instancias de\nEmpleado. (Obviamente, esto se podr�a haber armado de otra manera)\n\nAs� que para dos formas iguales de herencia, conceptualmente no tenemos\nuna �nica soluci�n para el problema de cuantas instancias de la primera\nclase debemos guardar, depende del caso. \n\nAdem�s, existe otro problema, y es (en el primer ejemplo), que pasa si hago\nHemafrodita.mear()? tiene que mear parado o sentado? Tanto Mujer como Hombre\nimplementan mear() (&#39;virtual&#39; o no en Persona), pero cual tengo que usar en\neste caso? Nuevamente, para una misma forma de herencia no hay conceptualmente\nun criterio automatico de resoluci�n, depende del caso especifico.\n\nHasta donde conozco, los lenguajes intentan resolver esto de una de estas\nformas:\n\n1- Directamente no permitiendo herencia m�ltiple\n\n2- No permitiendo herencia m�ltiple pero proveyendo alg�n tipo de mecanismo\n   para sustituirla (adem�s de composici�n), como Categor�as /\n   Protocolos/Interfases (algo remotamente similar a las abstract base\n   classes de C++).\n\n   Ej, clase B hereda de A pero a la vez declara que soporta el protocolo C (\n   esto es, una instancia B puede recibir un conjunto C de mensajes determinado\n   ). El protocolo/interfase no define variables nuevas, solo una &#39;api&#39;.\n\n3- Intentando linearizar el grafo de ancestros, con mayor o menor\n   cuidado/warnings sobre las ambig�edades (ej, CLOS). Seg�n el ejemplo\n   anterior, en Python:\n\n    class Humano:\n        def respirar(self):\n                pass\n\n    class Mujer(Humano):\n        def mear(self):\n                print &#39;sentada&#39;\n        def be_cute(self):\n                pass\n\n    class Hombre(humano):\n        def programar(self):\n                print &#39;se agrando adva y ni una mina&#39;\n        def mear(self):\n                print &#39;parado&#39;\n\n    class Hemafrodita(Mujer,Hombre):\n        pass\n\n  Entonces:\n\n        &gt;&gt;&gt; rene = Hemafrodita()\n        &gt;&gt;&gt; rene.mear()\n        sentada\n        &gt;&gt;&gt; \n\n  Y si hubiese sido:\n\n    class Hemafrodita(Hombre,Mujer):\n        pass\n\n    &gt;&gt;&gt; rene = Hemafrodita()\n    &gt;&gt;&gt; rene.mear()\n    parado\n    &gt;&gt;&gt; \n\n  Lo que pasa aqui es que &#39;linealiza&#39; el arbol de herencia, d�ndole\n  m�s prioridad a lo que se especifico primero al declarar los ancestros\n  de cada clase. En el segundo caso, la resoluci�n de mensajes queda as�:\n\n    Hemafrodita-&gt;Hombre-&gt;Mujer-&gt;Humano\n\n  Y por definicion se guarda una sola instancia de Humano.\n\nIgualmente con los lenguajes que no son fuertemente tipados / que usan dynamic\nbinding, este problema es un poco bastante menos grave, ya que se puede usar\ncomposicion en vez de H.M. en una mayor cantidad de casos. No se precisa\ndeclarar a un objeto de una determinada clase para poder mandarle un mensaje X. \n\nSo, IMHO en C++ es conveniente no usar H.M. salvo en muy especiales casos,\ny en los cuales hay que intentar que sea con abstract base classes. \n\n&lt;/RANT&gt;\n\nAhh.. me desahogu� :)\n\n\n- Nahuel Greco            Web Development - Open Source - \n- http://www.codenix.com  Game Programming - Research   -\n- Coding / sysadmin       Networking. The answer is 42. -\n\n"}}