{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"WELCOME_MSG"}]},{"resourceType":"PHOTO","capabilities":[{"name":"READ"},{"name":"UPLOAD"},{"name":"UPLOADTEMP"}]},{"resourceType":"FILE","capabilities":[{"name":"READ"},{"name":"CREATE"}]},{"resourceType":"MEMBER","capabilities":[{"name":"READ"}]},{"resourceType":"LINK","capabilities":[{"name":"CREATE"},{"name":"READ"}]},{"resourceType":"CALENDAR","capabilities":[{"name":"READ"}]},{"resourceType":"DATABASE","capabilities":[{"name":"READ"},{"name":"READ_DATA"},{"name":"CREATE"}]},{"resourceType":"POLL","capabilities":[{"name":"READ"},{"name":"VOTE"},{"name":"CREATE"}]},{"resourceType":"MESSAGE","capabilities":[{"name":"CREATE"},{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[{"name":"READ"},{"name":"UPLOAD"}]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[{"name":"READ"}]},{"resourceType":"POST","capabilities":[{"name":"READ"},{"name":"CREATE"}]},{"resourceType":"PIN","capabilities":[{"name":"DELETE"},{"name":"UPDATE"},{"name":"READ"},{"name":"CREATE"}]}],"subStatus":"NORMAL","groupUrl":"ar.groups.yahoo.com","intlCode":"ar"},"comscore":"pageview_candidate","ygData":{"userId":88100136,"authorName":"Jose Lambolay","from":"&quot;Jose Lambolay&quot; &lt;lambolay@...&gt;","replyTo":"LIST","senderId":"g4ZNmEBdQgSEVF3ffLYlL9SdCDFdYE3xWAlyCWanNm8ru1qX5MdbAUyY4bww07cgl7vT-6d2BMd3P6GlGdvTybq0JxozqxVCjS3O","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [ADVA] RE: interfases adaptables din\u0010","postDate":"1030469112","msgId":5361,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDAxMzIwMWMyNGRlZSRiM2QyZmY2MCRhNjdhODI4Y0B3OThsYW1ib2xheT4="},"prevInTopic":5352,"nextInTopic":5364,"prevInTime":5360,"nextInTime":5362,"topicId":5347,"numMessagesInTopic":8,"msgSnippet":"... From: Javier F. Otaegui  To: JuegosAR@gruposyahoo.com.ar  Date: Lunes, 26 de Agosto de 2002 10:14 a.m. ","rawEmail":"Return-Path: &lt;lambolay@...&gt;\r\nX-Sender: lambolay@...\r\nX-Apparently-To: JuegosAR@...\r\nReceived: (EGP: mail-8_1_0_1); 27 Aug 2002 17:21:18 -0000\r\nReceived: (qmail 43111 invoked from network); 27 Aug 2002 17:21:17 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m8.grp.scd.yahoo.com with QMQP; 27 Aug 2002 17:21:17 -0000\r\nReceived: from unknown (HELO mercurio.feedback.net.ar) (200.69.65.8)\n  by mta3.grp.scd.yahoo.com with SMTP; 27 Aug 2002 17:21:15 -0000\r\nReceived: from w98lambolay (host137.200.61.143.ifxnw.com.ar [200.61.143.137])\n\tby mercurio.feedback.net.ar (Postfix) with SMTP id 300A53C3\n\tfor &lt;JuegosAR@...&gt;; Tue, 27 Aug 2002 14:23:10 -0300 (ART)\r\nMessage-ID: &lt;013201c24dee$b3d2ff60$a67a828c@w98lambolay&gt;\r\nTo: &lt;JuegosAR@...&gt;\r\nSubject: =?iso-8859-1?Q?Re:_=5BADVA=5D_RE:_interfases_adaptables_din=10?=\r\nDate: Tue, 27 Aug 2002 14:25:12 -0300\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: 8bit\r\nX-Priority: 3\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook Express 4.72.3155.0\r\nX-MimeOLE: Produced By Microsoft MimeOLE V4.72.3155.0\r\nFrom: &quot;Jose Lambolay&quot; &lt;lambolay@...&gt;\r\nX-Yahoo-Group-Post: member; u=88100136\r\n\r\n\n-----Original Message-----\nFrom: Javier F. Otaegui &lt;javier@...&gt;\nTo: JuegosAR@... &lt;JuegosAR@...&gt;\nDate: Lunes, 26 de Agosto de 2002 10:14 a.m.\nSubject: Re: [ADVA] RE: interfases adaptables din\u0010\n\n\n&gt;muy interesante....... sin lugar a dudas el binding din�mico es muy\n&gt;poderoso, como as� tambi�n lo ser�a poder hacer el codigo reentrante (no se\n&gt;el termino exacto) en el sentido de poder llamar a una funci�n que reciba\nun\n&gt;string y corra eso (programaci�n din�mica?)\n&gt;\n&gt;Soporta el Python esto? Porque si lo soporta es entonces MUY poderoso y me\n&gt;voy a tener que callar la boca y darte la raz�n.....\nyes it can\n\n\n&gt;\n&gt;Por supuesto que siempre est� el tema de cuanta performance se pierde al\n&gt;interpretar codigo (y encima din�mico). Me sorprendi� leer el art�culo de\n&gt;Unreal y ver que cosas que se llaman todo el tiempo intensivamente est�n\n&gt;scripteadas.\n&gt;\n&gt;Una �ltima pregunta: Python vs Lua? Cual es la diferencia? ventajas de una\n&gt;sobre otra o no?\nel python es de multiproposito, pero se usa mucho para lo que es internet,\nprototyping y otras cuantas. Las ventajas del python, como ya dijeron, es\nque es mucho mas completo tanto como por el lenguaje en si (sus\nconstrucciones) como por su standard library. Y no es tan malo para embedar,\nsolo hay que buscar las herramientas justas(swing, ilu).\nLua tal vez es mas rapido ya que por ahi no es tan extenso como python y\nademas esta mucho mas destinado a ser embedded que python, que esta hecho\npara correr solo ademas de embedar. Ademas lua esta pensado para los juegos,\npython no. Ahora que lo pienso, estaria bueo hacer un dialecto de python\npara los games\n\n\n&gt;\n&gt;\n&gt;----- Original Message -----\n&gt;From: &quot;Nahuel Greco&quot; &lt;nahu@...&gt;\n&gt;To: &lt;JuegosAR@...&gt;\n&gt;Sent: Monday, August 26, 2002 2:38 AM\n&gt;Subject: Re: [ADVA] RE: interfases adaptables din\u0010\n&gt;\n&gt;\n&gt;&gt; On Sun, 25 Aug 2002 21:56:45 -0700\n&gt;&gt; &quot;Ale Palmero&quot; &lt;apalmero@...&gt; wrote:\n&gt;&gt;\n&gt;&gt; &gt; A la vez termin� de leer Code complete y mi gran\n&gt;&gt; &gt; duda es si todo esto ( adaptadores entre componentes, proxies,\n&gt;delegacion,\n&gt;&gt; &gt; jerarquias din�micas ) se aplica a los juegos hoy dia.\n&gt;&gt; &gt; No hace mucho que Carmack predicaba en contra de c++ y que la herencia\n&gt;&gt; &gt; multiple por ejemplo era mala palabra.\n&gt;&gt; &gt;\n&gt;&gt; &gt; Segun parece, directx lo est� usando pero no termino de convencerme....\n&gt;&gt; &gt;\n&gt;&gt;\n&gt;&gt; No le des demasiada bola a Carmack en lo relativo a arquitectura de\n&gt;Software\n&gt;&gt; (en gral), es mejor en ese campo leer a gente como Martin Fowler o Kent\n&gt;Beck.\n&gt;&gt; Esta bien criticar a C++, pero no tiene mucho sentido cuando la critica\n&gt;&gt; apunta a idolatrar a C :)\n&gt;&gt;\n&gt;&gt; &lt;NIGHTLY-PRO-DYNAMIC-LANGUAGES-RANT&gt;\n&gt;&gt;\n&gt;&gt; Con respecto a tu gran duda, justamente, IMHO uno de los problemas para\nla\n&gt;&gt; aplicaci�n de esas t�cnicas en games, es que los games se suelen hacer en\n&gt;C++,\n&gt;&gt; y C++ es a pain in the ass en la mayor�a de los casos (flames a mi!). Por\n&gt;&gt; ejemplo, no es lo mismo hacer un Proxy asi:\n&gt;&gt;\n&gt;&gt;     class Casita {\n&gt;&gt;         int        num_paredes;\n&gt;&gt;         bool       made_of_chocolate;\n&gt;&gt;     public:\n&gt;&gt;         Casita()   { (...) }\n&gt;&gt;         ~Casita()  { (...) }\n&gt;&gt;         dibujar()  { (...) }\n&gt;&gt; romper()   { (...) }\n&gt;&gt;         hacerla_de_chocolate() { (...) }\n&gt;&gt;     };\n&gt;&gt;\n&gt;&gt;     // Notar que me tengo que tomar todo el trabajo de transcribir\n&gt;&gt;     // metodo por metodo en el proxy:\n&gt;&gt;     class ProxyACasita {\n&gt;&gt;         Casita *casita;\n&gt;&gt;     public:\n&gt;&gt;         Casita() { casita = new Casita(); } // inicializado aqui para\n&gt;&gt;                                             // simplificar\n&gt;&gt;         ~Casita() { delete casita; }\n&gt;&gt;         dibujar() {\n&gt;&gt;                     casita-&gt;dibujar()\n&gt;&gt;                     }\n&gt;&gt;         romper() {\n&gt;&gt;                     casita-&gt;romper()\n&gt;&gt;                     }\n&gt;&gt;         hacerla_de_chocolate() {\n&gt;&gt;                         casita-&gt;hacerla_de_chocolate()\n&gt;&gt;                     }\n&gt;&gt;     };\n&gt;&gt;\n&gt;&gt; Que hacerlo as� (python):\n&gt;&gt;\n&gt;&gt;     class Casita:\n&gt;&gt;         def __init__(self):\n&gt;&gt;             self.num_paredes = 2\n&gt;&gt;             self.made_of_chocolate = 2\n&gt;&gt;         def dibujar(self):\n&gt;&gt;                 print &quot;Dibujada&quot;\n&gt;&gt;         def romper(self):\n&gt;&gt;                 (...)\n&gt;&gt;         def hacerla_de_chocolate:\n&gt;&gt;                 (...)\n&gt;&gt;\n&gt;&gt;    class Autito:\n&gt;&gt;         def __init__(self):\n&gt;&gt;             (...)\n&gt;&gt;         def orientar(self, grados):\n&gt;&gt;                 print &quot;Orientado&quot;\n&gt;&gt;                 self.orientacion = grados\n&gt;&gt;\n&gt;&gt; # Ahora creo una clase Proxy --Generica--:\n&gt;&gt;\n&gt;&gt;     class DebugProxy:\n&gt;&gt;         def __init__(self,dest):\n&gt;&gt;             self.destinatario = dest\n&gt;&gt;         def __getattr__( self, mensaje):\n&gt;&gt;             # ejemplo de algo que podria hacer\n&gt;&gt;             print mensaje,&quot;fue llamado&quot;\n&gt;&gt;             return getattr( self.destinatario, mensaje )\n&gt;&gt;\n&gt;&gt; So, luego puedo hacer:\n&gt;&gt;\n&gt;&gt;     &gt;&gt;&gt; una_casita_lejana = DebugProxy(Casita())\n&gt;&gt;     &gt;&gt;&gt; una_casita_lejana.dibujar()\n&gt;&gt;     dibujar fue llamado\n&gt;&gt;     Dibujada\n&gt;&gt;     &gt;&gt;&gt; auto = DebugProxy(Autito())\n&gt;&gt;     &gt;&gt;&gt; auto.orientar(3)\n&gt;&gt;     orientar fue llamado\n&gt;&gt;     Orientado\n&gt;&gt;     &gt;&gt;&gt;\n&gt;&gt;\n&gt;&gt; Not� que la clase &quot;DebugProxy&quot; es gen�rica, solo tuve que hacerla una vez\n&gt;&gt; para cualquier clase en la que la quiera aplicar. Tampoco tuve que\ntomarme\n&gt;&gt; el trabajo de copiar (ni mantener a trav�s de las versiones) toda la\n&gt;interfaz\n&gt;&gt; de la clase a la que le quiero proxy&#39;ear las instancias. La interfaz del\n&gt;&gt; proxy se adapta a cualquier m�todo nuevo que le agregue a Casita o\nAutito.\n&gt;&gt; No es nada magico ni un caso especial, es natural de pensar que uno puede\n&gt;&gt; crear un objeto que simplemente le tira todos los mensajes que le mandan\n&gt;&gt; a �l a otro objeto. Que C++ no soporte naturalmente eso es problema de �l\n&gt;:)\n&gt;&gt;\n&gt;&gt; Siguiendo con esto, pensa en la dificultad inherente a C++ para usar\n&gt;Proxys con\n&gt;&gt; objetos que son remotos (est�n en otra m�quina), y a los que no le\nconoces\n&gt;la\n&gt;&gt; interfaz por adelantado. No es imposible, pero hay que laburarlo, y no te\n&gt;va a\n&gt;&gt; quedar elegante, cuando en un lenguaje din�mico no son m�s de 15 lineas\nde\n&gt;&gt; code. So, son los limites del C++, COM+ es solo un intento por emparchar\n&gt;esos\n&gt;&gt; downsides del lenguaje.\n&gt;&gt;\n&gt;&gt; Obviamente, cuando codeemos C++, no porque sea m�s dif�cil/trabajoso\nvamos\n&gt;a\n&gt;&gt; dejar de &#39;aplicar&#39;, conscientemente o no, los design patterns. Design\n&gt;patterns\n&gt;&gt; que originalmente fueron pensados en Smalltalk para formalizar y dar un\n&gt;&gt; vocabulario a cosas que ya se ven�an haciendo (la implementaci�n de un\n&gt;Proxy en\n&gt;&gt; ST es &#39;similar&#39; a la que puse anteriormente en py, en el sentido que es\n&gt;&gt; &#39;dinamica&#39;/natural). Usarlos en C++ es como intentar encastrar un cubo de\n&gt;&gt; hierro en un agujero cilindrico, pero hay que hacerlo aunque quede todo\n&gt;roto\n&gt;&gt; y feo. Mientras que con los lenguajes din�micos no tenemos un cilindro\n&gt;sino\n&gt;&gt; una pelota, pero es de plastilina :)\n&gt;&gt;\n&gt;&gt; So, de usar C++, IMHO hay que intentar minimizar su uso y aplicarlo solo\n&gt;para\n&gt;&gt; lowlevel, y arriba un lenguaje &#39;de scripting&#39;/dinamico.\n&gt;&gt;\n&gt;&gt; En cuanto a la herencia m�ltiple, el problema conceptual t�pico con el\nque\n&gt;te\n&gt;&gt; podes encontrar es:\n&gt;&gt;\n&gt;&gt;      Humano\n&gt;&gt;      /    &#92;\n&gt;&gt;   Mujer    Hombre\n&gt;&gt;     &#92;       /\n&gt;&gt;    Hemafrodita\n&gt;&gt;\n&gt;&gt; (Nota, con H.M. el grafo de herencia se te puede complicar mucho m�s,\neste\n&gt;es\n&gt;&gt; un ejemplo simple, sin H.M. tenes la seguridad de que siempre es un tree)\n&gt;&gt;\n&gt;&gt; F�jate, seg�n ese gr�fico, tanto una Mujer como un Hombre son Humanos, el\n&gt;&gt; Hemafrodita tambi�n lo es, pero en una instancia de Hemafrodita, tenemos\n&gt;que\n&gt;&gt; mantener una o dos instancias de Humano? en este caso se podr�a resolver\n&gt;&gt; manteniendo una sola instancia, pero hay otros casos en donde tenemos que\n&gt;&gt; guardar dos instancias de la primera clase:\n&gt;&gt;\n&gt;&gt;             Empleado\n&gt;&gt;              /   &#92;\n&gt;&gt;           Mozo   Programador\n&gt;&gt;             &#92;     /\n&gt;&gt;     ArgentinoQueNoLlegaAFinDeMes\n&gt;&gt;\n&gt;&gt; En este caso, Empleado podr�a tener una variable que sea\n&gt;&quot;lugar_de_trabajo&quot;,\n&gt;&gt; un Mozo tiene un lugar de trabajo y se lo setea al Empleado, lo mismo un\n&gt;&gt; Programador a Sueldo, pero que pasa con el tipo que tiene dos laburos, el\n&gt;&gt; ArgentinoQueNoLlegaAFinDeMes ? Si tiene una sola instancia de Empleado,\n&gt;&gt; entonces va a haber conflicto, en este caso se precisan dos instancias de\n&gt;&gt; Empleado. (Obviamente, esto se podr�a haber armado de otra manera)\n&gt;&gt;\n&gt;&gt; As� que para dos formas iguales de herencia, conceptualmente no tenemos\n&gt;&gt; una �nica soluci�n para el problema de cuantas instancias de la primera\n&gt;&gt; clase debemos guardar, depende del caso.\n&gt;&gt;\n&gt;&gt; Adem�s, existe otro problema, y es (en el primer ejemplo), que pasa si\n&gt;hago\n&gt;&gt; Hemafrodita.mear()? tiene que mear parado o sentado? Tanto Mujer como\n&gt;Hombre\n&gt;&gt; implementan mear() (&#39;virtual&#39; o no en Persona), pero cual tengo que usar\n&gt;en\n&gt;&gt; este caso? Nuevamente, para una misma forma de herencia no hay\n&gt;conceptualmente\n&gt;&gt; un criterio automatico de resoluci�n, depende del caso especifico.\n&gt;&gt;\n&gt;&gt; Hasta donde conozco, los lenguajes intentan resolver esto de una de estas\n&gt;&gt; formas:\n&gt;&gt;\n&gt;&gt; 1- Directamente no permitiendo herencia m�ltiple\n&gt;&gt;\n&gt;&gt; 2- No permitiendo herencia m�ltiple pero proveyendo alg�n tipo de\n&gt;mecanismo\n&gt;&gt;    para sustituirla (adem�s de composici�n), como Categor�as /\n&gt;&gt;    Protocolos/Interfases (algo remotamente similar a las abstract base\n&gt;&gt;    classes de C++).\n&gt;&gt;\n&gt;&gt;    Ej, clase B hereda de A pero a la vez declara que soporta el protocolo\n&gt;C (\n&gt;&gt;    esto es, una instancia B puede recibir un conjunto C de mensajes\n&gt;determinado\n&gt;&gt;    ). El protocolo/interfase no define variables nuevas, solo una &#39;api&#39;.\n&gt;&gt;\n&gt;&gt; 3- Intentando linearizar el grafo de ancestros, con mayor o menor\n&gt;&gt;    cuidado/warnings sobre las ambig�edades (ej, CLOS). Seg�n el ejemplo\n&gt;&gt;    anterior, en Python:\n&gt;&gt;\n&gt;&gt;     class Humano:\n&gt;&gt;         def respirar(self):\n&gt;&gt;                 pass\n&gt;&gt;\n&gt;&gt;     class Mujer(Humano):\n&gt;&gt;         def mear(self):\n&gt;&gt;                 print &#39;sentada&#39;\n&gt;&gt;         def be_cute(self):\n&gt;&gt;                 pass\n&gt;&gt;\n&gt;&gt;     class Hombre(humano):\n&gt;&gt;         def programar(self):\n&gt;&gt;                 print &#39;se agrando adva y ni una mina&#39;\n&gt;&gt;         def mear(self):\n&gt;&gt;                 print &#39;parado&#39;\n&gt;&gt;\n&gt;&gt;     class Hemafrodita(Mujer,Hombre):\n&gt;&gt;         pass\n&gt;&gt;\n&gt;&gt;   Entonces:\n&gt;&gt;\n&gt;&gt;         &gt;&gt;&gt; rene = Hemafrodita()\n&gt;&gt;         &gt;&gt;&gt; rene.mear()\n&gt;&gt;         sentada\n&gt;&gt;         &gt;&gt;&gt;\n&gt;&gt;\n&gt;&gt;   Y si hubiese sido:\n&gt;&gt;\n&gt;&gt;     class Hemafrodita(Hombre,Mujer):\n&gt;&gt;         pass\n&gt;&gt;\n&gt;&gt;     &gt;&gt;&gt; rene = Hemafrodita()\n&gt;&gt;     &gt;&gt;&gt; rene.mear()\n&gt;&gt;     parado\n&gt;&gt;     &gt;&gt;&gt;\n&gt;&gt;\n&gt;&gt;   Lo que pasa aqui es que &#39;linealiza&#39; el arbol de herencia, d�ndole\n&gt;&gt;   m�s prioridad a lo que se especifico primero al declarar los ancestros\n&gt;&gt;   de cada clase. En el segundo caso, la resoluci�n de mensajes queda as�:\n&gt;&gt;\n&gt;&gt;     Hemafrodita-&gt;Hombre-&gt;Mujer-&gt;Humano\n&gt;&gt;\n&gt;&gt;   Y por definicion se guarda una sola instancia de Humano.\n&gt;&gt;\n&gt;&gt; Igualmente con los lenguajes que no son fuertemente tipados / que usan\n&gt;dynamic\n&gt;&gt; binding, este problema es un poco bastante menos grave, ya que se puede\n&gt;usar\n&gt;&gt; composicion en vez de H.M. en una mayor cantidad de casos. No se precisa\n&gt;&gt; declarar a un objeto de una determinada clase para poder mandarle un\n&gt;mensaje X.\n&gt;&gt;\n&gt;&gt; So, IMHO en C++ es conveniente no usar H.M. salvo en muy especiales\ncasos,\n&gt;&gt; y en los cuales hay que intentar que sea con abstract base classes.\n&gt;&gt;\n&gt;&gt; &lt;/RANT&gt;\n&gt;&gt;\n&gt;&gt; Ahh.. me desahogu� :)\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; - Nahuel Greco            Web Development - Open Source -\n&gt;&gt; - http://www.codenix.com  Game Programming - Research   -\n&gt;&gt; - Coding / sysadmin       Networking. The answer is 42. -\n&gt;&gt;\n&gt;&gt; ADVA - Asociaci�n de Desarrolladores de Videojuegos Argentina.\n&gt;&gt;\n&gt;&gt; www.adva.com.ar\n&gt;&gt; -------------------------------------------------------.\n&gt;&gt;\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; Tu uso de Yahoo! Grupos est� sujeto a las\n&gt;http://ar.docs.yahoo.com/info/utos.html\n&gt;&gt;\n&gt;&gt;\n&gt;\n&gt;\n&gt;ADVA - Asociaci�n de Desarrolladores de Videojuegos Argentina.\n&gt;\n&gt;www.adva.com.ar\n&gt;-------------------------------------------------------.\n&gt;\n&gt;\n&gt;\n&gt;Tu uso de Yahoo! Grupos est� sujeto a las\nhttp://ar.docs.yahoo.com/info/utos.html\n&gt;\n&gt;\n\n\n"}}