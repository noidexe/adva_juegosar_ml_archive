{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"WELCOME_MSG"}]},{"resourceType":"PHOTO","capabilities":[{"name":"READ"},{"name":"UPLOAD"},{"name":"UPLOADTEMP"}]},{"resourceType":"FILE","capabilities":[{"name":"READ"},{"name":"CREATE"}]},{"resourceType":"MEMBER","capabilities":[{"name":"READ"}]},{"resourceType":"LINK","capabilities":[{"name":"CREATE"},{"name":"READ"}]},{"resourceType":"CALENDAR","capabilities":[{"name":"READ"}]},{"resourceType":"DATABASE","capabilities":[{"name":"READ"},{"name":"READ_DATA"},{"name":"CREATE"}]},{"resourceType":"POLL","capabilities":[{"name":"READ"},{"name":"VOTE"},{"name":"CREATE"}]},{"resourceType":"MESSAGE","capabilities":[{"name":"CREATE"},{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[{"name":"READ"},{"name":"UPLOAD"}]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[{"name":"READ"}]},{"resourceType":"POST","capabilities":[{"name":"READ"},{"name":"CREATE"}]},{"resourceType":"PIN","capabilities":[{"name":"DELETE"},{"name":"UPDATE"},{"name":"READ"},{"name":"CREATE"}]}],"subStatus":"NORMAL","groupUrl":"ar.groups.yahoo.com","intlCode":"ar"},"comscore":"pageview_candidate","ygData":{"userId":112566267,"authorName":"Nahuel Greco","from":"Nahuel Greco &lt;nahu@...&gt;","replyTo":"LIST","senderId":"E1t0yiC35waEl2J0kVpz44S8CJnKECkd7bhbRVGF8ic7Ypp7hBVkFyUMNWa-CF-6TWaesXSW4Yz-DVIjB2Yc-omIsz9576k","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [ADVA] RE: interfases adaptables din","postDate":"1030564931","msgId":5387,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMDIwODI4MTcwMjExLjNhMmY5MDMwLm5haHVAc29mdGhvbWUubmV0Pg==","inReplyToHeader":"PDAwMDYwMWMyNGUzOCRjYjZjNDI0MCQ2Y2ViNDZjOEBwY3dpbmRvd3M+","referencesHeader":"PDEwMzA0MTk4MTYuNTQ1LjcxMzc4Lm0xMkBncnVwb3N5YWhvby5jb20uYXI+CTwwMDA2MDFjMjRlMzgkY2I2YzQyNDAkNmNlYjQ2YzhAcGN3aW5kb3dzPg=="},"prevInTopic":5381,"nextInTopic":5399,"prevInTime":5386,"nextInTime":5388,"topicId":5381,"numMessagesInTopic":3,"msgSnippet":"On Tue, 27 Aug 2002 23:11:38 -0300 ... From: http://www.bell-labs.com/user/cope/Patterns/ICSE96/node3.html Software design patterns had their origin in the","rawEmail":"Return-Path: &lt;nahu@...&gt;\r\nX-Sender: nahu@...\r\nX-Apparently-To: JuegosAR@...\r\nReceived: (EGP: mail-8_1_0_1); 28 Aug 2002 20:02:15 -0000\r\nReceived: (qmail 15088 invoked from network); 28 Aug 2002 20:02:14 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m1.grp.scd.yahoo.com with QMQP; 28 Aug 2002 20:02:14 -0000\r\nReceived: from unknown (HELO www.codelarvs.com.ar) (200.63.162.179)\n  by mta1.grp.scd.yahoo.com with SMTP; 28 Aug 2002 20:02:11 -0000\r\nReceived: from darwin (darwin [192.168.1.1])\n\tby www.codelarvs.com.ar (Postfix) with SMTP id 3245A1C5835\n\tfor &lt;JuegosAR@...&gt;; Wed, 28 Aug 2002 17:02:12 -0300 (ART)\r\nDate: Wed, 28 Aug 2002 17:02:11 -0300\r\nTo: JuegosAR@...\r\nSubject: Re: [ADVA] RE: interfases adaptables din\r\nMessage-Id: &lt;20020828170211.3a2f9030.nahu@...&gt;\r\nIn-Reply-To: &lt;000601c24e38$cb6c4240$6ceb46c8@pcwindows&gt;\r\nReferences: &lt;1030419816.545.71378.m12@...&gt;\n\t&lt;000601c24e38$cb6c4240$6ceb46c8@pcwindows&gt;\r\nOrganization: Codenix\r\nX-Mailer: Sylpheed version 0.8.1 (GTK+ 1.2.10; i386-debian-linux-gnu)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 8bit\r\nFrom: Nahuel Greco &lt;nahu@...&gt;\r\nX-Yahoo-Group-Post: member; u=112566267\r\n\r\nOn Tue, 27 Aug 2002 23:11:38 -0300\n&quot;lgmdpl&quot; &lt;lgmdpl@...&gt; wrote:\n\n&gt; - Design Patterns de Gamma, el primero, est� en C++. Fue escrito para\n&gt; documentar buenas soluciones de dise�o que se reinventaban una y otra vez\n\nFrom:\n        http://www.bell-labs.com/user/cope/Patterns/ICSE96/node3.html\n\n    Software design patterns had their origin in the late 1980&#39;s when Ward\n    Cunningham and Kent Beck developed a set of patterns for developing elegant\n    user interfaces in Smalltalk [5]. At around the same time, Jim Coplien was\n    developing a catalog of language-specific C++ patterns called idioms\n    [9]. Meanwhile, Erich Gamma recognized the value of explicitly recording\n    recurring design structures while working on his doctoral dissertation on\n    object-oriented software development [16]. These people and others met and\n    intensified their discussions on patterns at a series of OOPSLA workshops\n    starting in 1991 organized by Bruce Anderson [4, 3] and by 1993 the first\n    version of a catalog of patterns was in draft form (summarized in [17])\n    which eventually formed the basis for the first book on design patterns\n    [18]. All of these activities were influenced by the works of Christopher\n    Alexander, a building architect and urban planner [2, 1] who coined the\n    term ``pattern&#39;&#39; to refer to recurring designs in (building)\n    architecture. In the summer of 1993, a small group of pattern enthusiasts\n    formed the ``Hillside Generative Patterns Group&#39;&#39; and subsequently\n    organized the first conference on patterns called the ``Pattern Languages\n    of Programming&#39;&#39; (PLoP) in 1994 [11].\n\nNota: el paper de Kent Beck se presento en OOPSLA del 87 (es el que estableci�\nla relaci�n entre las ideas de Christopher Alexander con la Ing. de Software).\nLa tesis de Gamma es del 88, la primera edici�n del libro de Gamma es del 94. \n\nEl abstract del paper de Kent Beck esta aqu�: http://c2.com/doc/oopsla87.html\n\n\n&gt; programando con orientaci�n a objetos. Sobre Smalltalk, no estoy seguro que\n&gt; &quot;design patterns&quot; sea una palabra tan fuerte... en una conferencia\n&gt; organizada por www.smalltalking.net, ante la pregunta sobre el dise�o de una\n\nQue bueno, a cual fuiste? yo particip� del seminario de la UTN, quiz�s nos\nvimos. Highly Recommended.\n\n\n&gt; aplicaci�n, reconocieron (no sin disimulado orgullo): no hay dise�o, uno\n&gt; tiene una idea general, y entra a mandar objetos y a relacionarlos... al\n&gt; final, alg�n dise�o queda :)\n\nSi, justamente no hablan tanto sobre patterns porque la mayor�a de ellos se\nhacen casi trivialmente dadas las facilidades del lenguaje/ambiente de ST. Pero\nf�jate que ellos no solamente intentan evitar hablar de patrones, sino que,\ncomo vos dec�s, no hablan de __dise�o__! abogan por una programaci�n\n&#39;evolutiva&#39; en donde uno vaya pensando el modelo no en el papel, sino\ndirectamente en el ST, y que al final como side effect te quede tu &#39;programa&#39;\nworkeando. Creo que dijeron eso no porque no existan los patterns o se dejen de\nusar, sino porque la mayor�a salen &#39;naturalmente&#39; en el lenguaje.\n\nPor lo que veo (estoy subscripto a la lista de smalltalking), no hablan de\npatterns, pero cuando hay que llamar a algo &quot;Proxy&quot;, se hace. Lo mismo cuando\nhablan de MVC, que podr�a verse como un pattern &#39;de m�s alto nivel&#39;, as� que es\nmedio relativo lo que dijeron. Formalizar al definir los patterns aporta\nvocabulario.\n\nNo capto la relaci�n que tiene lo ultimo que dec�s con tu argumentaci�n\nposterior sobre el Proxy (en donde lo que dec�s vale solo para un modelo\nidealizado de desarrollo en cascada / relevamiento, dise�o, implementaci�n).\n\n\n&gt; Cont� que despu�s pod�a ejecutar una herramienta que generaba \n&gt; autom�ticamente la documentaci�n a partir del c�digo terminado.\n\nBueno, eso es un ejemplo de lo que se puede hacer con &#39;metaprogramaci�n&#39;.\nEs otro mundo. No solo pueden generar la documentaci�n a partir del modelo\n(aunque no este terminado), sino que por ej, pueden recorrer din�micamente\nel modelo (programa) mientras &#39;esta corriendo&#39; y hacer los cambios que\nquieran de manera autom�tica. Un ejemplo quiz�s un poco simple: estaban\nhaciendo un wrapper a un motor 3D hecho en C (o C++, no recuerdo), y en\nlas clases hab�a varios m�todos que no estaban testeados. Esos m�todos\nten�an nombres as�:\n\n        NOT-TESTED-metodo1\n        NOT-TESTED-metodo2\n        metodo3\n        NOT-TESTED-metodo4\n\nEntonces, cuando un m�todo corr�a exitosamente, autom�ticamente se sacaba el\nNOT-TESTED de su nombre (y de todos los lugares en donde era llamado). As�\ncomo en este ejemplo, uno puede inventarse much�simas meta-formas de laburar\n(inclusive de manera distribuida con varios developers usando un server\nde coordinaci�n central, o whatever).\n\n\n&gt; - Justo elegiste el patr�n Proxy para mostrar las dificultades de C++... Con\n&gt; casi cualquier otro patr�n no ibas a encontrar dificultades. Igual no son\n&gt; tantas:\n&gt; Primero que el proxy en su versi�n adapter se usa para acceder a objetos que\n&gt; no cambian a trav�s de las versiones, por lo que no hay tal costo de\n&gt; mantenimiento...\n\nNo me refer�a solo a un cambio de versiones entre releases de aplicaciones,\nsino a las versiones de desarrollo diarias. Creo que es realista pensar que\nuno no da con la interfaz correcta y final en el primer intento.  \n\nSi te parece que maliciosamente eleg� justo Proxy, decime un par de patterns\ncon su ejemplo en C++ y vemos como quedan en py :)\n\n\n&gt; Y si su uso es otro, entonces est� incluido dentro del\n&gt; dise�o, y puede crearse una superclase gen�rica (para una clase particular),\n&gt; de modo de tener que actualizar una �nica clase aunque hayamos definido 100\n&gt; clases proxy (como en su modalidad decorator). \n\nComo ser�a eso?\n\n\n&gt; Y si te resulta muy tedioso\n&gt; escribir todas las funciones, existen generadores autom�ticos de c�digo:\n&gt; dada la definici�n de una clase en IDL se generan directamente las clases.\n&gt; S� de algunas empresas que utilizan un lenguaje propio (XML) para generar\n&gt; este tipo de clases. Y por supuesto, tanto IDL como XML pueden ser generados\n&gt; a partir de c�digo fuente.\n&gt; \n\nSi, se puede automatizar, pero ya estamos agregando tools externas para suplir\nuna deficiencia del lenguaje, algo similar pasa con el preprocesador que se\nutiliza para QT.. lo lindo es ver que pasa si acumulas varias de esas\nherramientas, ver si funcionan bien entre s�, etc. No le veo tanto sentido.\n\n\n&gt; &gt; es natural de pensar que uno puede crear un objeto que simplemente le tira\n&gt; &gt; todos los mensajes que le mandan a �l a otro objeto\n&gt; \n&gt; - Es natural pensar as� en un lenguaje din�mico. Cuando se quiere programar\n\nEs natural pensar as� en el concepto abstracto de objetos. Cuando me pase de\nC++ a python, y vi que en un framework se utilizaba mucho el pasar clases por\npar�metros, no me gust�, me pareci� que era algo adhoc, que no era natural, que\nlas clases no eran para manipularlas. Pero despu�s me d� cuenta que si uno\npiensa de manera abstracta, la clase tambi�n es un objeto, y que lo sea te\nresuelve un mont�n de cosas. Lo que sucedi� fue que al principio, como el �nico\nlenguaje &quot;OO&quot; que habia utilizado era C++, mi modelo mental de lo que eran los\nobjetos se basaba en C++, y modelizaba a partir de esa idea limitada. El modelo\nde objetos tal como se penso originalmente es inherentemente din�mico, por lo\nque esta muy lejos de mapearse 1:1 de manera elegante a un lenguaje tan est�tico\ncomo C++.\n\n\n&gt; con una m�nima esperanza de correctitud, algo muy usado es programar por\n&gt; contrato, y eso requiere interfaces claramente definidas, con sus nombres,\n&gt; respectivos tipos y comportamiento. Algo que con binding din�mico es\n&gt; pr�cticamente imposible. Y pretender usar binding din�mico en lenguajes que\n&gt; no son Smalltalk, como Python, hace inviable la construcci�n de aplicaciones\n&gt; de medianas a grandes, porque con 5000 objetos y 500 clases, si no hay tipos\n&gt; y detecci�n de errores en tiempo de compilaci�n, corregir un bug puede ser\n&gt; una pesadilla.\n&gt; \n\nPlis, explicame por qu� en este punto haces diferencia entre Smalltalk y\nPython.\n\nLo de tipado estricto/static binding/dise�o-por-contrato Vs. typeless/ dynamic\nbinding es una pol�mica mayor, m�s all� del tema de performance. Podr�amos\ndiscutir mucho, pero te prevengo que muchos capos ni se ponen de acuerdo entre\nellos sobre este tema, as� que podr�amos pasarnos bastante time discutiendo :)\n\nPersonalmente me siento m�s productivo sin chequeo de tipos, pero me gusta la\nidea de declaraci�n opcional de tipos para optimizar / consolidar las\ninterfases cuando ya quedan armadas.\n\nIgualmente lo que sienta personalmente en esto no tiene demasiado valor, porque\nlo que se cuestiona es si se puede laburar en equipo sin tipos. Pero f�jate que\nlas ultimas &#39;tendencias&#39; en ingenier�a de software apuntan m�s bien a los\nlenguajes din�micos (XP es natural en ST, nuevamente lo tenes a Kent Beck como\n&#39;formalizador&#39;(&quot;&quot;inventor&quot;&quot;) de XP usando ST :). Pero bueno, es discutible si\nen un equipo grande usar tipado est�tico es mejor, personalmente creo que no, y\nadem�s me parece que en los lenguajes din�micos podes inventar muchas t�cnicas\nque a falta de tipado te ayuden en la consistencia de tu programa, mientras que\na la vez no se si es posible inventar la flexibilidad para un lenguaje que es\nfuertemente tipado (Lo �nico que vi para lograr algo de esto son\npreprocesadores como lo de IDL, o MOC, pero son off-lenguaje y por lo tanto\nno elegantes).\n\n\n&gt; &gt; 3- Intentando linearizar el grafo de ancestros\n&gt; \n&gt; - Falt� s�lo la opci�n de permitirla, como hace C++ :) Pero hay un acuerdo\n&gt; en la comunidad OO en que no deber�a usarse nunca. En general se considera\n&gt; que la herencia m�ltiple es consecuencia de un mal dise�o... lo que no quita\n&gt; que cuando haya que extender un mal dise�o... :)\n&gt; \n\nLa opcion 3 tambi�n es permitirla. C++ deja m�ltiples instancias de la primera\nclase (&quot;Humano&quot;), (a menos que la clase Humano sea una ABC). C++ no lineariza,\nsino que tira el warning cuando hay ambig�edad y uno debe especificar de que\nclase base es el m�todo que quiere llamar (pens�ndolo abstractamente en objetos,\nesto seria como mandarle un mensaje a un objeto teniendo que pensar previamente\nen su constituci�n interna (IMHO es caca))\n\nSaludos,\n\n\n- Nahuel Greco            Web Development - Open Source - \n- http://www.codenix.com  Game Programming - Research   -\n- Coding / sysadmin       Networking. The answer is 42. -\n\n"}}