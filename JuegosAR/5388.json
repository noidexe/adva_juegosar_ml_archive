{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"WELCOME_MSG"}]},{"resourceType":"PHOTO","capabilities":[{"name":"READ"},{"name":"UPLOAD"},{"name":"UPLOADTEMP"}]},{"resourceType":"FILE","capabilities":[{"name":"READ"},{"name":"CREATE"}]},{"resourceType":"MEMBER","capabilities":[{"name":"READ"}]},{"resourceType":"LINK","capabilities":[{"name":"CREATE"},{"name":"READ"}]},{"resourceType":"CALENDAR","capabilities":[{"name":"READ"}]},{"resourceType":"DATABASE","capabilities":[{"name":"READ"},{"name":"CREATE"},{"name":"READ_DATA"}]},{"resourceType":"POLL","capabilities":[{"name":"READ"},{"name":"VOTE"},{"name":"CREATE"}]},{"resourceType":"MESSAGE","capabilities":[{"name":"CREATE"},{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[{"name":"READ"},{"name":"UPLOAD"}]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[{"name":"READ"}]},{"resourceType":"POST","capabilities":[{"name":"READ"},{"name":"CREATE"}]},{"resourceType":"PIN","capabilities":[{"name":"READ"},{"name":"UPDATE"},{"name":"CREATE"},{"name":"DELETE"}]}],"subStatus":"NORMAL","groupUrl":"ar.groups.yahoo.com","intlCode":"ar"},"comscore":"pageview_candidate","ygData":{"userId":40223085,"authorName":"juglarx dark","from":"&quot;juglarx dark&quot; &lt;juglarx@...&gt;","replyTo":"LIST","senderId":"3mxLktOZKO8Yy8_630wLeqkEhSSEIemOxY8xBjnvw2VmFvQ9_Q8I7iD-hcM3P9QQmI0RdYtc3i06QGt9xj_BDSIvp0GqfreD_cwX","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [ADVA] RE: interfases adaptables din","postDate":"1030578937","msgId":5388,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PEYxMDJReGo2d0w3WmxPWEdRZ28wMDAwNzgyYUBob3RtYWlsLmNvbT4="},"prevInTopic":5386,"nextInTopic":5390,"prevInTime":5387,"nextInTime":5389,"topicId":5386,"numMessagesInTopic":6,"msgSnippet":"Muy buen libro , este libro tambien esta bueno Large-Scale C++ Software Design ... _________________________________________________________________ Join the","rawEmail":"Return-Path: &lt;juglarx@...&gt;\r\nX-Sender: juglarx@...\r\nX-Apparently-To: JuegosAR@...\r\nReceived: (EGP: mail-8_1_0_1); 28 Aug 2002 23:55:37 -0000\r\nReceived: (qmail 60598 invoked from network); 28 Aug 2002 23:55:37 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m15.grp.scd.yahoo.com with QMQP; 28 Aug 2002 23:55:37 -0000\r\nReceived: from unknown (HELO hotmail.com) (216.33.237.102)\n  by mta3.grp.scd.yahoo.com with SMTP; 28 Aug 2002 23:55:37 -0000\r\nReceived: from mail pickup service by hotmail.com with Microsoft SMTPSVC;\n\t Wed, 28 Aug 2002 16:55:37 -0700\r\nReceived: from 148.233.239.24 by lw7fd.law7.hotmail.msn.com with HTTP;\n\tWed, 28 Aug 2002 23:55:37 GMT\r\nTo: JuegosAR@...\r\nBcc: \r\nSubject: Re: [ADVA] RE: interfases adaptables din\r\nDate: Wed, 28 Aug 2002 23:55:37 +0000\r\nMime-Version: 1.0\r\nContent-Type: text/plain; format=flowed\r\nMessage-ID: &lt;F102Qxj6wL7ZlOXGQgo0000782a@...&gt;\r\nX-OriginalArrivalTime: 28 Aug 2002 23:55:37.0354 (UTC) FILETIME=[67FBE6A0:01C24EEE]\r\nFrom: &quot;juglarx dark&quot; &lt;juglarx@...&gt;\r\nX-Yahoo-Group-Post: member; u=40223085\r\n\r\n\n\nMuy buen libro , este libro tambien esta bueno &quot;Large-Scale C++ Software \nDesign&quot;\n&gt;From: Nahuel Greco &lt;nahu@...&gt;\n&gt;Reply-To: JuegosAR@...\n&gt;To: JuegosAR@...\n&gt;Subject: Re: [ADVA] RE: interfases adaptables din\n&gt;Date: Wed, 28 Aug 2002 17:02:11 -0300\n&gt;\n&gt;On Tue, 27 Aug 2002 23:11:38 -0300\n&gt;&quot;lgmdpl&quot; &lt;lgmdpl@...&gt; wrote:\n&gt;\n&gt; &gt; - Design Patterns de Gamma, el primero, est� en C++. Fue escrito para\n&gt; &gt; documentar buenas soluciones de dise�o que se reinventaban una y otra \n&gt;vez\n&gt;\n&gt;From:\n&gt;         http://www.bell-labs.com/user/cope/Patterns/ICSE96/node3.html\n&gt;\n&gt;     Software design patterns had their origin in the late 1980&#39;s when Ward\n&gt;     Cunningham and Kent Beck developed a set of patterns for developing \n&gt;elegant\n&gt;     user interfaces in Smalltalk [5]. At around the same time, Jim Coplien \n&gt;was\n&gt;     developing a catalog of language-specific C++ patterns called idioms\n&gt;     [9]. Meanwhile, Erich Gamma recognized the value of explicitly \n&gt;recording\n&gt;     recurring design structures while working on his doctoral dissertation \n&gt;on\n&gt;     object-oriented software development [16]. These people and others met \n&gt;and\n&gt;     intensified their discussions on patterns at a series of OOPSLA \n&gt;workshops\n&gt;     starting in 1991 organized by Bruce Anderson [4, 3] and by 1993 the \n&gt;first\n&gt;     version of a catalog of patterns was in draft form (summarized in \n&gt;[17])\n&gt;     which eventually formed the basis for the first book on design \n&gt;patterns\n&gt;     [18]. All of these activities were influenced by the works of \n&gt;Christopher\n&gt;     Alexander, a building architect and urban planner [2, 1] who coined \n&gt;the\n&gt;     term ``pattern&#39;&#39; to refer to recurring designs in (building)\n&gt;     architecture. In the summer of 1993, a small group of pattern \n&gt;enthusiasts\n&gt;     formed the ``Hillside Generative Patterns Group&#39;&#39; and subsequently\n&gt;     organized the first conference on patterns called the ``Pattern \n&gt;Languages\n&gt;     of Programming&#39;&#39; (PLoP) in 1994 [11].\n&gt;\n&gt;Nota: el paper de Kent Beck se presento en OOPSLA del 87 (es el que \n&gt;estableci�\n&gt;la relaci�n entre las ideas de Christopher Alexander con la Ing. de \n&gt;Software).\n&gt;La tesis de Gamma es del 88, la primera edici�n del libro de Gamma es del \n&gt;94.\n&gt;\n&gt;El abstract del paper de Kent Beck esta aqu�: \n&gt;http://c2.com/doc/oopsla87.html\n&gt;\n&gt;\n&gt; &gt; programando con orientaci�n a objetos. Sobre Smalltalk, no estoy seguro \n&gt;que\n&gt; &gt; &quot;design patterns&quot; sea una palabra tan fuerte... en una conferencia\n&gt; &gt; organizada por www.smalltalking.net, ante la pregunta sobre el dise�o de \n&gt;una\n&gt;\n&gt;Que bueno, a cual fuiste? yo particip� del seminario de la UTN, quiz�s nos\n&gt;vimos. Highly Recommended.\n&gt;\n&gt;\n&gt; &gt; aplicaci�n, reconocieron (no sin disimulado orgullo): no hay dise�o, uno\n&gt; &gt; tiene una idea general, y entra a mandar objetos y a relacionarlos... al\n&gt; &gt; final, alg�n dise�o queda :)\n&gt;\n&gt;Si, justamente no hablan tanto sobre patterns porque la mayor�a de ellos se\n&gt;hacen casi trivialmente dadas las facilidades del lenguaje/ambiente de ST. \n&gt;Pero\n&gt;f�jate que ellos no solamente intentan evitar hablar de patrones, sino que,\n&gt;como vos dec�s, no hablan de __dise�o__! abogan por una programaci�n\n&gt;&#39;evolutiva&#39; en donde uno vaya pensando el modelo no en el papel, sino\n&gt;directamente en el ST, y que al final como side effect te quede tu \n&gt;&#39;programa&#39;\n&gt;workeando. Creo que dijeron eso no porque no existan los patterns o se \n&gt;dejen de\n&gt;usar, sino porque la mayor�a salen &#39;naturalmente&#39; en el lenguaje.\n&gt;\n&gt;Por lo que veo (estoy subscripto a la lista de smalltalking), no hablan de\n&gt;patterns, pero cuando hay que llamar a algo &quot;Proxy&quot;, se hace. Lo mismo \n&gt;cuando\n&gt;hablan de MVC, que podr�a verse como un pattern &#39;de m�s alto nivel&#39;, as� \n&gt;que es\n&gt;medio relativo lo que dijeron. Formalizar al definir los patterns aporta\n&gt;vocabulario.\n&gt;\n&gt;No capto la relaci�n que tiene lo ultimo que dec�s con tu argumentaci�n\n&gt;posterior sobre el Proxy (en donde lo que dec�s vale solo para un modelo\n&gt;idealizado de desarrollo en cascada / relevamiento, dise�o, \n&gt;implementaci�n).\n&gt;\n&gt;\n&gt; &gt; Cont� que despu�s pod�a ejecutar una herramienta que generaba\n&gt; &gt; autom�ticamente la documentaci�n a partir del c�digo terminado.\n&gt;\n&gt;Bueno, eso es un ejemplo de lo que se puede hacer con &#39;metaprogramaci�n&#39;.\n&gt;Es otro mundo. No solo pueden generar la documentaci�n a partir del modelo\n&gt;(aunque no este terminado), sino que por ej, pueden recorrer din�micamente\n&gt;el modelo (programa) mientras &#39;esta corriendo&#39; y hacer los cambios que\n&gt;quieran de manera autom�tica. Un ejemplo quiz�s un poco simple: estaban\n&gt;haciendo un wrapper a un motor 3D hecho en C (o C++, no recuerdo), y en\n&gt;las clases hab�a varios m�todos que no estaban testeados. Esos m�todos\n&gt;ten�an nombres as�:\n&gt;\n&gt;         NOT-TESTED-metodo1\n&gt;         NOT-TESTED-metodo2\n&gt;         metodo3\n&gt;         NOT-TESTED-metodo4\n&gt;\n&gt;Entonces, cuando un m�todo corr�a exitosamente, autom�ticamente se sacaba \n&gt;el\n&gt;NOT-TESTED de su nombre (y de todos los lugares en donde era llamado). As�\n&gt;como en este ejemplo, uno puede inventarse much�simas meta-formas de \n&gt;laburar\n&gt;(inclusive de manera distribuida con varios developers usando un server\n&gt;de coordinaci�n central, o whatever).\n&gt;\n&gt;\n&gt; &gt; - Justo elegiste el patr�n Proxy para mostrar las dificultades de C++... \n&gt;Con\n&gt; &gt; casi cualquier otro patr�n no ibas a encontrar dificultades. Igual no \n&gt;son\n&gt; &gt; tantas:\n&gt; &gt; Primero que el proxy en su versi�n adapter se usa para acceder a objetos \n&gt;que\n&gt; &gt; no cambian a trav�s de las versiones, por lo que no hay tal costo de\n&gt; &gt; mantenimiento...\n&gt;\n&gt;No me refer�a solo a un cambio de versiones entre releases de aplicaciones,\n&gt;sino a las versiones de desarrollo diarias. Creo que es realista pensar que\n&gt;uno no da con la interfaz correcta y final en el primer intento.\n&gt;\n&gt;Si te parece que maliciosamente eleg� justo Proxy, decime un par de \n&gt;patterns\n&gt;con su ejemplo en C++ y vemos como quedan en py :)\n&gt;\n&gt;\n&gt; &gt; Y si su uso es otro, entonces est� incluido dentro del\n&gt; &gt; dise�o, y puede crearse una superclase gen�rica (para una clase \n&gt;particular),\n&gt; &gt; de modo de tener que actualizar una �nica clase aunque hayamos definido \n&gt;100\n&gt; &gt; clases proxy (como en su modalidad decorator).\n&gt;\n&gt;Como ser�a eso?\n&gt;\n&gt;\n&gt; &gt; Y si te resulta muy tedioso\n&gt; &gt; escribir todas las funciones, existen generadores autom�ticos de c�digo:\n&gt; &gt; dada la definici�n de una clase en IDL se generan directamente las \n&gt;clases.\n&gt; &gt; S� de algunas empresas que utilizan un lenguaje propio (XML) para \n&gt;generar\n&gt; &gt; este tipo de clases. Y por supuesto, tanto IDL como XML pueden ser \n&gt;generados\n&gt; &gt; a partir de c�digo fuente.\n&gt; &gt;\n&gt;\n&gt;Si, se puede automatizar, pero ya estamos agregando tools externas para \n&gt;suplir\n&gt;una deficiencia del lenguaje, algo similar pasa con el preprocesador que se\n&gt;utiliza para QT.. lo lindo es ver que pasa si acumulas varias de esas\n&gt;herramientas, ver si funcionan bien entre s�, etc. No le veo tanto sentido.\n&gt;\n&gt;\n&gt; &gt; &gt; es natural de pensar que uno puede crear un objeto que simplemente le \n&gt;tira\n&gt; &gt; &gt; todos los mensajes que le mandan a �l a otro objeto\n&gt; &gt;\n&gt; &gt; - Es natural pensar as� en un lenguaje din�mico. Cuando se quiere \n&gt;programar\n&gt;\n&gt;Es natural pensar as� en el concepto abstracto de objetos. Cuando me pase \n&gt;de\n&gt;C++ a python, y vi que en un framework se utilizaba mucho el pasar clases \n&gt;por\n&gt;par�metros, no me gust�, me pareci� que era algo adhoc, que no era natural, \n&gt;que\n&gt;las clases no eran para manipularlas. Pero despu�s me d� cuenta que si uno\n&gt;piensa de manera abstracta, la clase tambi�n es un objeto, y que lo sea te\n&gt;resuelve un mont�n de cosas. Lo que sucedi� fue que al principio, como el \n&gt;�nico\n&gt;lenguaje &quot;OO&quot; que habia utilizado era C++, mi modelo mental de lo que eran \n&gt;los\n&gt;objetos se basaba en C++, y modelizaba a partir de esa idea limitada. El \n&gt;modelo\n&gt;de objetos tal como se penso originalmente es inherentemente din�mico, por \n&gt;lo\n&gt;que esta muy lejos de mapearse 1:1 de manera elegante a un lenguaje tan \n&gt;est�tico\n&gt;como C++.\n&gt;\n&gt;\n&gt; &gt; con una m�nima esperanza de correctitud, algo muy usado es programar por\n&gt; &gt; contrato, y eso requiere interfaces claramente definidas, con sus \n&gt;nombres,\n&gt; &gt; respectivos tipos y comportamiento. Algo que con binding din�mico es\n&gt; &gt; pr�cticamente imposible. Y pretender usar binding din�mico en lenguajes \n&gt;que\n&gt; &gt; no son Smalltalk, como Python, hace inviable la construcci�n de \n&gt;aplicaciones\n&gt; &gt; de medianas a grandes, porque con 5000 objetos y 500 clases, si no hay \n&gt;tipos\n&gt; &gt; y detecci�n de errores en tiempo de compilaci�n, corregir un bug puede \n&gt;ser\n&gt; &gt; una pesadilla.\n&gt; &gt;\n&gt;\n&gt;Plis, explicame por qu� en este punto haces diferencia entre Smalltalk y\n&gt;Python.\n&gt;\n&gt;Lo de tipado estricto/static binding/dise�o-por-contrato Vs. typeless/ \n&gt;dynamic\n&gt;binding es una pol�mica mayor, m�s all� del tema de performance. Podr�amos\n&gt;discutir mucho, pero te prevengo que muchos capos ni se ponen de acuerdo \n&gt;entre\n&gt;ellos sobre este tema, as� que podr�amos pasarnos bastante time discutiendo \n&gt;:)\n&gt;\n&gt;Personalmente me siento m�s productivo sin chequeo de tipos, pero me gusta \n&gt;la\n&gt;idea de declaraci�n opcional de tipos para optimizar / consolidar las\n&gt;interfases cuando ya quedan armadas.\n&gt;\n&gt;Igualmente lo que sienta personalmente en esto no tiene demasiado valor, \n&gt;porque\n&gt;lo que se cuestiona es si se puede laburar en equipo sin tipos. Pero f�jate \n&gt;que\n&gt;las ultimas &#39;tendencias&#39; en ingenier�a de software apuntan m�s bien a los\n&gt;lenguajes din�micos (XP es natural en ST, nuevamente lo tenes a Kent Beck \n&gt;como\n&gt;&#39;formalizador&#39;(&quot;&quot;inventor&quot;&quot;) de XP usando ST :). Pero bueno, es discutible \n&gt;si\n&gt;en un equipo grande usar tipado est�tico es mejor, personalmente creo que \n&gt;no, y\n&gt;adem�s me parece que en los lenguajes din�micos podes inventar muchas \n&gt;t�cnicas\n&gt;que a falta de tipado te ayuden en la consistencia de tu programa, mientras \n&gt;que\n&gt;a la vez no se si es posible inventar la flexibilidad para un lenguaje que \n&gt;es\n&gt;fuertemente tipado (Lo �nico que vi para lograr algo de esto son\n&gt;preprocesadores como lo de IDL, o MOC, pero son off-lenguaje y por lo tanto\n&gt;no elegantes).\n&gt;\n&gt;\n&gt; &gt; &gt; 3- Intentando linearizar el grafo de ancestros\n&gt; &gt;\n&gt; &gt; - Falt� s�lo la opci�n de permitirla, como hace C++ :) Pero hay un \n&gt;acuerdo\n&gt; &gt; en la comunidad OO en que no deber�a usarse nunca. En general se \n&gt;considera\n&gt; &gt; que la herencia m�ltiple es consecuencia de un mal dise�o... lo que no \n&gt;quita\n&gt; &gt; que cuando haya que extender un mal dise�o... :)\n&gt; &gt;\n&gt;\n&gt;La opcion 3 tambi�n es permitirla. C++ deja m�ltiples instancias de la \n&gt;primera\n&gt;clase (&quot;Humano&quot;), (a menos que la clase Humano sea una ABC). C++ no \n&gt;lineariza,\n&gt;sino que tira el warning cuando hay ambig�edad y uno debe especificar de \n&gt;que\n&gt;clase base es el m�todo que quiere llamar (pens�ndolo abstractamente en \n&gt;objetos,\n&gt;esto seria como mandarle un mensaje a un objeto teniendo que pensar \n&gt;previamente\n&gt;en su constituci�n interna (IMHO es caca))\n&gt;\n&gt;Saludos,\n&gt;\n&gt;\n&gt;- Nahuel Greco            Web Development - Open Source -\n&gt;- http://www.codenix.com  Game Programming - Research   -\n&gt;- Coding / sysadmin       Networking. The answer is 42. -\n\n\n\n\n_________________________________________________________________\nJoin the world�s largest e-mail service with MSN Hotmail. \nhttp://www.hotmail.com\n\n\n"}}