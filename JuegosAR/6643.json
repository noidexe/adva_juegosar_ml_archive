{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"WELCOME_MSG"}]},{"resourceType":"PHOTO","capabilities":[{"name":"READ"},{"name":"UPLOAD"},{"name":"UPLOADTEMP"}]},{"resourceType":"FILE","capabilities":[{"name":"READ"},{"name":"CREATE"}]},{"resourceType":"MEMBER","capabilities":[{"name":"READ"}]},{"resourceType":"LINK","capabilities":[{"name":"CREATE"},{"name":"READ"}]},{"resourceType":"CALENDAR","capabilities":[{"name":"READ"}]},{"resourceType":"DATABASE","capabilities":[{"name":"READ"},{"name":"READ_DATA"},{"name":"CREATE"}]},{"resourceType":"POLL","capabilities":[{"name":"READ"},{"name":"VOTE"},{"name":"CREATE"}]},{"resourceType":"MESSAGE","capabilities":[{"name":"CREATE"},{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[{"name":"READ"},{"name":"UPLOAD"}]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[{"name":"READ"}]},{"resourceType":"POST","capabilities":[{"name":"READ"},{"name":"CREATE"}]},{"resourceType":"PIN","capabilities":[{"name":"DELETE"},{"name":"UPDATE"},{"name":"READ"},{"name":"CREATE"}]}],"subStatus":"NORMAL","groupUrl":"ar.groups.yahoo.com","intlCode":"ar"},"comscore":"pageview_candidate","ygData":{"userId":50779123,"authorName":"Sebastian Uribe","from":"Sebastian Uribe &lt;suribe@...&gt;","replyTo":"LIST","senderId":"mIeRw_YLTQucfUWyNTpe_X4aGpmdweR_GqaYxb4UkcaTMLnezRGzz2ULp9eOu-cEQB_ZOBRiY4pX9fXqLGursSlL754KsNXRbxY_hKQ","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [ADVA] Assembly en Visual C++","postDate":"1039011804","msgId":6643,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDNERUUwRkRDLjc5NkY1MTI5QGl0b2NodS5jb20uYXI+","referencesHeader":"PDIwMDIxMjAxMDEyOTMwLjEzMTc3LnFtYWlsQHdlYjEzMDA4Lm1haWwueWFob28uY29tPiA8T0UzOXMzV2NwNGFYQ0lUNW5TZjAwMDBiNTM5QGhvdG1haWwuY29tPiA8M0RFQkFGNkUuMzE5MTY4NzdAaXRvY2h1LmNvbS5hcj4gPDAwNzEwMWMyOWFiMyRmNDMxNzJhMCQ3NzEwMjljOEBNSUNST1NPRlQ+IDxPRTQyYURGdVhDcFU2cTVpamIxMDAwMDg3NmJAaG90bWFpbC5jb20+"},"prevInTopic":6642,"nextInTopic":6644,"prevInTime":6642,"nextInTime":6644,"topicId":6600,"numMessagesInTopic":27,"msgSnippet":"Ignacio, El VTune, si no me equivoco, es un programa pensado para ayudarte a optimizar código para procesadores Intel (es de Intel). Lo que necesitás es un","rawEmail":"Return-Path: &lt;suribe@...&gt;\r\nX-Sender: suribe@...\r\nX-Apparently-To: JuegosAR@...\r\nReceived: (EGP: mail-8_2_3_0); 4 Dec 2002 14:21:54 -0000\r\nReceived: (qmail 32558 invoked from network); 4 Dec 2002 14:21:54 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m3.grp.scd.yahoo.com with QMQP; 4 Dec 2002 14:21:54 -0000\r\nReceived: from unknown (HELO mail.itochu.com.ar) (200.61.198.14)\n  by mta3.grp.scd.yahoo.com with SMTP; 4 Dec 2002 14:21:52 -0000\r\nReceived: from itochu.com.ar (SURIBE [192.168.1.197]) by mail.itochu.com.ar with SMTP (Microsoft Exchange Internet Mail Service Version 5.5.2653.13)\n\tid XS0PR6YP; Wed, 4 Dec 2002 11:31:13 -0300\r\nMessage-ID: &lt;3DEE0FDC.796F5129@...&gt;\r\nDate: Wed, 04 Dec 2002 11:23:24 -0300\r\nOrganization: ITOCHU Argentina S.A.\r\nX-Mailer: Mozilla 4.8 [en] (Windows NT 5.0; U)\r\nX-Accept-Language: en\r\nMIME-Version: 1.0\r\nTo: JuegosAR@...\r\nSubject: Re: [ADVA] Assembly en Visual C++\r\nReferences: &lt;20021201012930.13177.qmail@...&gt; &lt;OE39s3Wcp4aXCIT5nSf0000b539@...&gt; &lt;3DEBAF6E.31916877@...&gt; &lt;007101c29ab3$f43172a0$771029c8@MICROSOFT&gt; &lt;OE42aDFuXCpU6q5ijb10000876b@...&gt;\r\nContent-Type: multipart/alternative;\n boundary=&quot;------------7A95BF48F64E10529E595CBD&quot;\r\nFrom: Sebastian Uribe &lt;suribe@...&gt;\r\nX-Yahoo-Group-Post: member; u=50779123\r\n\r\n\r\n--------------7A95BF48F64E10529E595CBD\r\nContent-Type: text/plain; charset=iso-8859-1\r\nContent-Transfer-Encoding: 8bit\r\n\r\n\nIgnacio,\n\n    El VTune, si no me equivoco, es un programa pensado para ayudarte a\noptimizar c�digo para procesadores Intel (es de Intel). Lo que necesit�s\nes un simple profiler que te muestre el tiempo de ejecuci�n de cada\nfunci�n.\n\n    Como te dije antes, el VC te permite hacer profiling. Ten�s que\ncambiar una opci�n de compilaci�n (Enable profiling) en los settings del\nproyecto, recompilarlo, y despu�s elegir &quot;Profile...&quot; dentro del men�\nBuild. Va a correr m�s lento, pero cuando termine te tira la lista de\nfunciones.\n\n Te doy un ejemplo del output para un programa m�o:\n\n\nProfile: Function timing, sorted by time\nDate:    Wed Dec 04 10:54:37 2002\n\n\nProgram Statistics\n------------------\n    Command line at 2002 Dec 04 10:54:\n&quot;C:&#92;prg&#92;tanqueGL&#92;Release&#92;tanqueGL&quot;\n    Total time: 6964.175 millisecond\n    Time outside of functions: 72.312 millisecond\n    Call depth: 16\n    Total functions: 1183\n    Total hits: 180888\n    Function coverage: 56.3%\n    Overhead Calculated 8\n    Overhead Average 8\n\nModule Statistics for tanquegl.exe\n----------------------------------\n    Time in module: 6891.863 millisecond\n    Percent of time in module: 100.0%\n    Functions in module: 1183\n    Hits in module: 180888\n    Module function coverage: 56.3%\n\n        Func          Func+Child           Hit\n        Time   %         Time      %      Count  Function\n---------------------------------------------------------\n    4138.054  60.0     6327.975  91.8      389 doRender(void) (game.obj)\n\n    1760.836  25.5     2143.155  31.1      389\nGLContext::preRender(void) (glcontext.obj)\n     379.140   5.5      379.140   5.5       69\nCamera::extractFrustum(void) (camera.obj)\n     141.508   2.1      148.780   2.2        1 GLContext::init(char\n*,int,int,int,int,long (*)(struct HWND__ *,unsigned int,unsigned\nint,long)) (glcontext.obj)\n      93.459   1.4     6594.183  95.7        1 mainLoop(void) (game.obj)\n\n      86.222   1.3       94.560   1.4     1216 WndProc(struct HWND__\n*,unsigned int,unsigned int,long) (main.obj)\n      63.438   0.9       63.702   0.9        1 GLContext::quit(void)\n(glcontext.obj)\n      44.294   0.6       44.294   0.6       13 std::__Fiopen(char const\n*,int) (fiopen.obj)\n      19.813   0.3       36.635   0.5     3890 Unit::render(void)\n(unit.obj)\n      19.062   0.3       25.766   0.4        1 GLContext::show(int)\n(glcontext.obj)\n      16.892   0.2       16.892   0.2    21006 Building::render(void)\n(building.obj)\n      16.892   0.2       16.892   0.2    21006 Object::render(void)\n(building.obj)\n      16.037   0.2       16.037   0.2        1\nGLContext::setCamera(class Camera &) (glcontext.obj)\n      14.159   0.2       19.225   0.3        1 _$E17 (building.obj)\n       7.860   0.1        7.860   0.1     6700\nUnit::estimatedPosition(long) (unit.obj)\n       5.974   0.1        5.974   0.1     5602\nstd::basic_filebuf&lt;char,struct std::char_traits&lt;char&gt; &gt;::uflow(void)\n(game.obj)\n\n    ... a partir de ac� hay cientos de funciones que comen una porci�n\ninsignificante del tiempo.\n\n*    La funci�n que m�s tiempo come es la que llama a otras para que\nhagan el rendering:\n\nvoid doRender(void) {\n    GL.preRender();\n\n    GL.render(&objectRenderList);\n    GL.render(&unitRenderList);\n\n    GL.Disable(GL_DEPTH_TEST);\n        selector.render();\n    GL.Enable(GL_DEPTH_TEST);\n\n    GL.postRender();\n}\n\n    GLrender es muy simple:\n\nvoid GLContext::render(UnitPtrList *renderList) {\n    for (UnitPtrList::iterator i = renderList-&gt;begin() ; i !=\nrenderList-&gt;end() ; i++) {\n        glPushMatrix();\n            (*i)-&gt;render();\n        glPopMatrix();\n    }\n}\n\n    Y eso es lo que hace que tarde mucho: No estoy ordenando por ningun\ncriterio (textura), ni probando si los objetos se ven o no (Frustum\nCulling) ni nada. Tampoco estoy usando ningun tipo de modelos con\ncomplejidad adaptiva. Mejorando esas cosas, seguro que el tiempo se\nreduce a la mitad. Es una funci�n que hace lo que se espera de ella, y\nnada m�s.\n\n*    La funci�n GLContext::preRender hace la operaci�n que se come m�s\ntiempo del programa: limpiar el buffer de OpenGL (glClear). Por mucho\nassembler que uses, nunca vas a poder optimizar eso (es solo una llamada\nal driver y, creeme, los drivers tienen mucho m�s optimizado el clear de\nlo que alguien externo a la compa��a que hace la placa pueda hacerlo\njam�s). Come m�s de un 20% del tiempo del programa haciendo renders a un\npoco menos de 640x480, 50fps.\n\n\n    Cada programa es un caso particular para hacer profiling, y ten�s\nque tener alguna idea del dominio del problema para poder optimizar.\nPeor que no optimizar es optimizar el lugar equivocado, porque te\nconsume tiempo y probablemente hace que tu c�digo sea peor.\n\n    Espero que esto te de una m�nima idea del proceso de profiling...\n\nIgnacio Liverotti wrote:\n\n&gt;  �Ten�s alguno para recomendar que sea gratuito? VTune es el �nico que\n&gt; conozco y creo que es pago.\n\n--\nSebasti�n Uribe\nITOCHU Argentina S.A.\nsuribe@...\n\n\r\n--------------7A95BF48F64E10529E595CBD\r\nContent-Type: text/html; charset=us-ascii\r\nContent-Transfer-Encoding: 7bit\r\n\r\n&lt;!doctype html public &quot;-//w3c//dtd html 4.0 transitional//en&quot;&gt;\n&lt;html&gt;\n&lt;body bgcolor=&quot;#FFFFFF&quot;&gt;\n&nbsp;\n&lt;br&gt;Ignacio,\n&lt;p&gt;&nbsp;&nbsp;&nbsp; El VTune, si no me equivoco, es un programa pensado\npara ayudarte a optimizar c&oacute;digo para procesadores Intel (es de\nIntel). Lo que necesit&aacute;s es un simple profiler que te muestre el\ntiempo de ejecuci&oacute;n de cada funci&oacute;n.\n&lt;p&gt;&nbsp;&nbsp;&nbsp; Como te dije antes, el VC te permite hacer profiling.\nTen&eacute;s que cambiar una opci&oacute;n de compilaci&oacute;n (Enable\nprofiling) en los settings del proyecto, recompilarlo, y despu&eacute;s\nelegir &quot;Profile...&quot; dentro del men&uacute; Build. Va a correr m&aacute;s\nlento, pero cuando termine te tira la lista de funciones.\n&lt;p&gt;&nbsp;Te doy un ejemplo del output para un programa m&iacute;o:\n&lt;br&gt;&nbsp;\n&lt;p&gt;Profile: Function timing, sorted by time\n&lt;br&gt;Date:&nbsp;&nbsp;&nbsp; Wed Dec 04 10:54:37 2002\n&lt;br&gt;&nbsp;\n&lt;p&gt;Program Statistics\n&lt;br&gt;------------------\n&lt;br&gt;&nbsp;&nbsp;&nbsp; Command line at 2002 Dec 04 10:54: &quot;C:&#92;prg&#92;tanqueGL&#92;Release&#92;tanqueGL&quot;\n&lt;br&gt;&nbsp;&nbsp;&nbsp; Total time: 6964.175 millisecond\n&lt;br&gt;&nbsp;&nbsp;&nbsp; Time outside of functions: 72.312 millisecond\n&lt;br&gt;&nbsp;&nbsp;&nbsp; Call depth: 16\n&lt;br&gt;&nbsp;&nbsp;&nbsp; Total functions: 1183\n&lt;br&gt;&nbsp;&nbsp;&nbsp; Total hits: 180888\n&lt;br&gt;&nbsp;&nbsp;&nbsp; Function coverage: 56.3%\n&lt;br&gt;&nbsp;&nbsp;&nbsp; Overhead Calculated 8\n&lt;br&gt;&nbsp;&nbsp;&nbsp; Overhead Average 8\n&lt;p&gt;Module Statistics for tanquegl.exe\n&lt;br&gt;----------------------------------\n&lt;br&gt;&nbsp;&nbsp;&nbsp; Time in module: 6891.863 millisecond\n&lt;br&gt;&nbsp;&nbsp;&nbsp; Percent of time in module: 100.0%\n&lt;br&gt;&nbsp;&nbsp;&nbsp; Functions in module: 1183\n&lt;br&gt;&nbsp;&nbsp;&nbsp; Hits in module: 180888\n&lt;br&gt;&nbsp;&nbsp;&nbsp; Module function coverage: 56.3%\n&lt;p&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Func&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\nFunc+Child&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\nHit\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Time&nbsp;&nbsp; %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\nTime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Count&nbsp;\nFunction\n&lt;br&gt;---------------------------------------------------------\n&lt;br&gt;&nbsp;&nbsp;&nbsp; 4138.054&nbsp; 60.0&nbsp;&nbsp;&nbsp;&nbsp; 6327.975&nbsp;\n91.8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 389 doRender(void) (game.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp; 1760.836&nbsp; 25.5&nbsp;&nbsp;&nbsp;&nbsp; 2143.155&nbsp;\n31.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 389 GLContext::preRender(void) (glcontext.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp; 379.140&nbsp;&nbsp; 5.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n379.140&nbsp;&nbsp; 5.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 69 Camera::extractFrustum(void)\n(camera.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp; 141.508&nbsp;&nbsp; 2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n148.780&nbsp;&nbsp; 2.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 GLContext::init(char\n*,int,int,int,int,long (*)(struct HWND__ *,unsigned int,unsigned int,long))\n(glcontext.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 93.459&nbsp;&nbsp; 1.4&nbsp;&nbsp;&nbsp;&nbsp;\n6594.183&nbsp; 95.7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 mainLoop(void)\n(game.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 86.222&nbsp;&nbsp; 1.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n94.560&nbsp;&nbsp; 1.4&nbsp;&nbsp;&nbsp;&nbsp; 1216 WndProc(struct HWND__\n*,unsigned int,unsigned int,long) (main.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 63.438&nbsp;&nbsp; 0.9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n63.702&nbsp;&nbsp; 0.9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 GLContext::quit(void)\n(glcontext.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 44.294&nbsp;&nbsp; 0.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n44.294&nbsp;&nbsp; 0.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13 std::__Fiopen(char\nconst *,int) (fiopen.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19.813&nbsp;&nbsp; 0.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n36.635&nbsp;&nbsp; 0.5&nbsp;&nbsp;&nbsp;&nbsp; 3890 Unit::render(void)\n(unit.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19.062&nbsp;&nbsp; 0.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n25.766&nbsp;&nbsp; 0.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 GLContext::show(int)\n(glcontext.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16.892&nbsp;&nbsp; 0.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n16.892&nbsp;&nbsp; 0.2&nbsp;&nbsp;&nbsp; 21006 Building::render(void) (building.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16.892&nbsp;&nbsp; 0.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n16.892&nbsp;&nbsp; 0.2&nbsp;&nbsp;&nbsp; 21006 Object::render(void) (building.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16.037&nbsp;&nbsp; 0.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n16.037&nbsp;&nbsp; 0.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 GLContext::setCamera(class\nCamera &amp;) (glcontext.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14.159&nbsp;&nbsp; 0.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n19.225&nbsp;&nbsp; 0.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 _$E17\n(building.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7.860&nbsp;&nbsp; 0.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n7.860&nbsp;&nbsp; 0.1&nbsp;&nbsp;&nbsp;&nbsp; 6700 Unit::estimatedPosition(long)\n(unit.obj)\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.974&nbsp;&nbsp; 0.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n5.974&nbsp;&nbsp; 0.1&nbsp;&nbsp;&nbsp;&nbsp; 5602 std::basic_filebuf&lt;char,struct\nstd::char_traits&lt;char&gt; &gt;::uflow(void) (game.obj)\n&lt;p&gt;&nbsp;&nbsp;&nbsp; ... a partir de ac&aacute; hay cientos de funciones\nque comen una porci&oacute;n insignificante del tiempo.\n&lt;p&gt;*&nbsp;&nbsp;&nbsp; La funci&oacute;n que m&aacute;s tiempo come es\nla que llama a otras para que hagan el rendering:\n&lt;p&gt;void doRender(void) {\n&lt;br&gt;&nbsp;&nbsp;&nbsp; GL.preRender();\n&lt;p&gt;&nbsp;&nbsp;&nbsp; GL.render(&amp;objectRenderList);\n&lt;br&gt;&nbsp;&nbsp;&nbsp; GL.render(&amp;unitRenderList);\n&lt;p&gt;&nbsp;&nbsp;&nbsp; GL.Disable(GL_DEPTH_TEST);\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; selector.render();\n&lt;br&gt;&nbsp;&nbsp;&nbsp; GL.Enable(GL_DEPTH_TEST);\n&lt;p&gt;&nbsp;&nbsp;&nbsp; GL.postRender();\n&lt;br&gt;}\n&lt;p&gt;&nbsp;&nbsp;&nbsp; GLrender es muy simple:\n&lt;p&gt;void GLContext::render(UnitPtrList *renderList) {\n&lt;br&gt;&nbsp;&nbsp;&nbsp; for (UnitPtrList::iterator i = renderList-&gt;begin()\n; i != renderList-&gt;end() ; i++) {\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n(*i)-&gt;render();\n&lt;br&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();\n&lt;br&gt;&nbsp;&nbsp;&nbsp; }\n&lt;br&gt;}\n&lt;p&gt;&nbsp;&nbsp;&nbsp; Y eso es lo que hace que tarde mucho: No estoy ordenando\npor ningun criterio (textura), ni probando si los objetos se ven o no (Frustum\nCulling) ni nada. Tampoco estoy usando ningun tipo de modelos con complejidad\nadaptiva. Mejorando esas cosas, seguro que el tiempo se reduce a la mitad.\nEs una funci&oacute;n que hace lo que se espera de ella, y nada m&aacute;s.\n&lt;p&gt;*&nbsp;&nbsp;&nbsp; La funci&oacute;n GLContext::preRender hace la operaci&oacute;n\nque se come m&aacute;s tiempo del programa: limpiar el buffer de OpenGL\n(glClear). Por mucho assembler que uses, nunca vas a poder optimizar eso\n(es solo una llamada al driver y, creeme, los drivers tienen mucho m&aacute;s\noptimizado el clear de lo que alguien externo a la compa&ntilde;&iacute;a\nque hace la placa pueda hacerlo jam&aacute;s). Come m&aacute;s de un 20%\ndel tiempo del programa haciendo renders a un poco menos de 640x480, 50fps.\n&lt;br&gt;&nbsp;\n&lt;p&gt;&nbsp;&nbsp;&nbsp; Cada programa es un caso particular para hacer profiling,\ny ten&eacute;s que tener alguna idea del dominio del problema para poder\noptimizar. Peor que no optimizar es optimizar el lugar equivocado, porque\nte consume tiempo y probablemente hace que tu c&oacute;digo sea peor.\n&lt;p&gt;&nbsp;&nbsp;&nbsp; Espero que esto te de una m&iacute;nima idea del\nproceso de profiling...\n&lt;p&gt;Ignacio Liverotti wrote:\n&lt;blockquote TYPE=CITE&gt;&nbsp;&lt;font face=&quot;Arial&quot;&gt;&lt;font size=-1&gt;&iquest;Ten&eacute;s\nalguno para recomendar que sea gratuito? VTune es el &uacute;nico que conozco\ny creo que es pago.&lt;/font&gt;&lt;/font&gt;&lt;/blockquote&gt;\n\n&lt;p&gt;--\n&lt;br&gt;Sebasti&aacute;n Uribe\n&lt;br&gt;ITOCHU Argentina S.A.\n&lt;br&gt;suribe@...\n&lt;br&gt;&nbsp;\n&lt;/body&gt;\n&lt;/html&gt;\n\r\n--------------7A95BF48F64E10529E595CBD--\r\n\n"}}