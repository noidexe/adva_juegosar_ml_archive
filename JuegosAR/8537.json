{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"WELCOME_MSG"}]},{"resourceType":"PHOTO","capabilities":[{"name":"READ"},{"name":"UPLOAD"},{"name":"UPLOADTEMP"}]},{"resourceType":"FILE","capabilities":[{"name":"READ"},{"name":"CREATE"}]},{"resourceType":"MEMBER","capabilities":[{"name":"READ"}]},{"resourceType":"LINK","capabilities":[{"name":"CREATE"},{"name":"READ"}]},{"resourceType":"CALENDAR","capabilities":[{"name":"READ"}]},{"resourceType":"DATABASE","capabilities":[{"name":"READ_DATA"},{"name":"READ"},{"name":"CREATE"}]},{"resourceType":"POLL","capabilities":[{"name":"READ"},{"name":"VOTE"},{"name":"CREATE"}]},{"resourceType":"MESSAGE","capabilities":[{"name":"CREATE"},{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[{"name":"READ"},{"name":"UPLOAD"}]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[{"name":"READ"}]},{"resourceType":"POST","capabilities":[{"name":"READ"},{"name":"CREATE"}]},{"resourceType":"PIN","capabilities":[{"name":"DELETE"},{"name":"READ"},{"name":"UPDATE"},{"name":"CREATE"}]}],"subStatus":"NORMAL","groupUrl":"ar.groups.yahoo.com","intlCode":"ar"},"comscore":"pageview_candidate","ygData":{"userId":63432839,"authorName":"Juan Linietsky","from":"Juan Linietsky &lt;coding@...&gt;","replyTo":"LIST","senderId":"rFIDoRa7NKuzCfqpg6zOwVuiU6f4U7if05vM8VWC6l3cZwOFLwOGswBc0r0oj_L_v7aNzUam5PY9SWBQPsuQIV9yIEjbJ3zg0O9w","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [ADVA] Ok, explicacion de como funciona.","postDate":"1066541765","msgId":8537,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMDMxMDE5MDIzNi4wNTEzNy5jb2RpbmdAcmVkdXouY29tLmFyPg==","inReplyToHeader":"PDAwMTkwMWMzOTVmNiQ3MDI1NmMyMCRjNzIyZmVhOUBkZWZhdWx0Pg==","referencesHeader":"PDIwMDMxMDE4MjM1NS40ODYwOS5jb2RpbmdAcmVkdXouY29tLmFyPiA8MDAxOTAxYzM5NWY2JDcwMjU2YzIwJGM3MjJmZWE5QGRlZmF1bHQ+"},"prevInTopic":8536,"nextInTopic":8538,"prevInTime":8536,"nextInTime":8538,"topicId":8536,"numMessagesInTopic":10,"msgSnippet":"... Ah, bajate el demo (ejecutable si podes). Ok, paso a explicar (nota, intercambie un par de mails con Ken Silverman, el autor, que fue muy gentil en","rawEmail":"Return-Path: &lt;coding@...&gt;\r\nX-Sender: coding@...\r\nX-Apparently-To: JuegosAR@...\r\nReceived: (qmail 62351 invoked from network); 19 Oct 2003 05:38:28 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m10.grp.scd.yahoo.com with QMQP; 19 Oct 2003 05:38:28 -0000\r\nReceived: from unknown (HELO john.anime.com.ar) (64.113.39.216)\n  by mta2.grp.scd.yahoo.com with SMTP; 19 Oct 2003 05:38:28 -0000\r\nReceived: from tatan.codelarvs.com.ar (OL93-140.fibertel.com.ar [24.232.140.93])\n\tby john.anime.com.ar (8.10.2/8.10.2) with ESMTP id h9GNHGH07777\n\tfor &lt;JuegosAR@...&gt;; Thu, 16 Oct 2003 19:17:17 -0400\r\nTo: JuegosAR@...\r\nSubject: Re: [ADVA] Ok, explicacion de como funciona.\r\nDate: Sun, 19 Oct 2003 02:36:05 -0300\r\nUser-Agent: KMail/1.5.3\r\nReferences: &lt;200310182355.48609.coding@...&gt; &lt;001901c395f6$70256c20$c722fea9@default&gt;\r\nIn-Reply-To: &lt;001901c395f6$70256c20$c722fea9@default&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n  charset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: 8bit\r\nContent-Disposition: inline\r\nMessage-Id: &lt;200310190236.05137.coding@...&gt;\r\nFrom: Juan Linietsky &lt;coding@...&gt;\r\nX-Yahoo-Group-Post: member; u=63432839\r\n\r\nOn Sunday 19 October 2003 01:05, Leonardo M. Falaschini wrote:\n&gt; Un poco de castellano para los analfabetos de la programaci�n, por favor...\n&gt; Por que yo veo unos tipitos con pistolitas colgados de unas sogas... no veo\n&gt; lo reolucionario (el que no sabe es como el que no v�, dicen) ...\n&gt;\n&gt; Shal�,\n&gt; Leo.\n\nAh, bajate el demo (ejecutable si podes).\nOk, paso a explicar (nota, intercambie un par de mails con Ken Silverman,\nel autor, que fue muy gentil en explicarme varias dudas que tenia sobre como \nesta implementado)\n\nPor suerte o desgracia de ustedes me operaron de un pie la semana pasada\ny apenas puedo caminar, asi que voy a dedicar un buen rato\nde esta noche de sabado que paso frente a la computadora a explicar\nque es exactamente esto y porque es importante. Como quienes me conocen saben \nque NO soy partidario de hacerme el facho usando terminos muy tecnicos a \nmenos que no quede otra.. Voy a tratar de explicar esto de manera que me \nentiendan tanto programadores como no programadores.\n\nProbablemente entienden la diferencia entre graficos vectoriales y graficos \npixelados.  Los vectoriales son aquellos graficos independientes de \nresolucion, y que se pueden mostrar en cualquier tamanio sin que pierdan\ndetalle (Ejemplo, FLASH, o Painter). Los graficos pixelados son aquellos\ncompuestos por una cantidad finita de elementos o pixeles, onda el photoshop,\ny los formatos de imagen mas comunes. (gif, png, jpg, tga,etc) (Obviamente\nque una vez procesados todos se transforman en pixeles, pero estamos halando\nde como es la &quot;materia prima&quot;). Las placas aceleradoras 3D, y por lo tanto los \njuegos funcionan todos con primtiivas vectoriales llamadas &quot;poligonos&quot; donde\ntodo es representado por figuras geometricas ubicadas arbitrariamente en el \nespacio. \n\nLo que esta nueva tecnologia que acabo de postear ahi arriba representa es una\ntecnica para lograr crear mundos pixelados en 3D, donde los pixeles pasan a \nser &quot;cubos&quot;. Esto evidentemente no se puede hacer tan facilmente como 2D por\nla simple razon de que no dan los recursos. Imaginense si una imagen de \n1024x1024, donde un pixel son 2 bytes (16bits) ocupa: 1024^2*2=1MB\nlo mismo en 3D ocupa 1024^3*2=1GB. Llejos de lo que puede procesar\nuna maquina de hoy en dia.\n\nObviamente cabe tambien destacar las ventajas de esta tecnica, porque\nsino no se estaria investigando. Ya que no existe el &quot;reuso&quot; de texturas,\ny un voxel es de hecho una &quot;molecula&quot;, podemos decir que el realismo\nde una escena es directamente proporcional al tamanio de un voxel.\nCon esto se pueden lograr escenas (al menos estaticas/pregeneradas\npor ahora) que simulen con mucho realismo a sus contrapartes\nreales, y ademas facilitando tenicas como caustics/shadows/photon mapping, \netc.\n\nEvidentemente existen limitaciones de CPU. El renderizado de los &quot;voxels&quot; se \nrealiza de la siguiente manera. Se define una distancia\narbitraria desde el ojo del observador hasta la pantalla (esto se llama \n&quot;znear&quot;). Ahora, recorriendo cada pixel de la pantalla, trazamos una\nlinea desde el ojo del observador pasando por ese pixel, suiguendo\nen esa direccion recorremos el &quot;bitmap en 3D&quot; HASTA que nos topamos\ncon un voxel. Si nos topamos con uno, ponemos el color del respectivo\nen el pixel correspondiente y seguimos con el proximo.\nBueno, obviamente como se dan cuenta, esto implica muchisimo CPU\ntambien.\n\n\nPero Ken Silverman le encontro la vuelta, y paso a explicar como:\n(reitero, no me estoy mandando cualquiera, parte de este proceso me lo explico \nel).\n\n-Podemos decir que es imposible ver a traves de los materiales solidos,\npor lo tanto, aun si fueran huecos con un milimetro de espesor, no notariamos\nla diferencia. Entonces, si dijeramos que nuestras escenas y objetos son asi,\nhabria muchisimo espacio libre. Este espacio libre se puede comprimir usando\nuna tecnica que se llama &quot;RLE&quot; (run length encoding o algo asi), que dice\n&quot;ok, aca hay 20 voxels libres, 1 ocupado con estos datos, y otros 20 libres&quot;.\nEsto es mucho mas corto que decir &quot;libre, libre, libre, libre, libre, libre \n(..) libre, ocupado, libre, libre, libre, etc&quot;. De esta manera se ahorra \nmemoria! Al parecer ken desarrollo una tecnica que permite  leer los\ndatos en este formato en tiempo real, lo que le ahorra muchisima memoria.\n(obviamente no me explico como es, asi que ya tienen un buen topic para \nresearch ;)\n\n-Aun asi, hacer raytracing en una matriz en 3 dimensiones es horriblemente \nlento, imaginense que si cada voxel mide 5 centimetros, y queremos ver tan \nsolo cien metros.. vamos a terminar procesando 10mil voxels por cada\npixel de la pantalla. Obviamente esto es una brutalidad. Uno podria\nhablar de tecnicas de oclusion y demas, pero hay una alternativa mas facil:\nSe puede tener el mundo replicado varias veces, cada vez con la mitad\nde resolucion. Para quienes estudiaron algoritmos y esas cosas, ya saben\nque esto significa SOLO casi duplicar la memoria. Los mipmaps de una\ntextura en una placa 3D estan guardados de la misma forma.\nEntonces, al ir recorriendo el mundo el rayo se va pasando de &quot;resolucion&#39;\na medida que se aleja del observador, ahorrando mucho pero mucho cpu :)\n\nBueno, esas vienen a ser las optimizaciones principales, pero aun asi \nqueda una mas..\n\n-En tecnicas de raytracing, compresion de imaganes y video (el jpg/mpg creo \nque usaba algo como esta tecnica? corrijanme si me equivoco) hay algo \nconocido como &quot;adaptative subsampling&quot;. Como cada pixel se procesa\nde manera independiente y no necesita saber lo que pasa con los vecinos,\nprimero se procesa una imagen en menos resolucion. Es decir, imaginense\nque la resolucion de la pantalla es 640x480. Primero vamos a procesar\nlos pixeles cual su ubicacion es multiplo de 4 tanto en eje X como Y, la \nimagen se veria como algo asi:\n.  .  .  .  .  .  .  .  .  .\n.  .  .  .  .  .  .  .  .  .\n.  .  .  .  .  .  .  .  .  .\n.  .  .  .  .  .  .  .  .  .\n\nFijense que queda como una grilla con celdas de 4x4 pixeles. Ahora, en cada \ncuadradito de la grilla nos fijamos si en las esquinas el color es muy pero \nmuy parecido, si es asi, simplemente usamos un &quot;gradiente/rampa de color&quot;\npara conectar a los cuatro y marcamos ese cuadradito como que no se toca.\nOk, ahora volvemos al paso uno, y procesamos los pixeles que son\nmultiplos de 2 tanto en eje X como en Y y repetimos el proceso. ( Obviamente \nque si el pixel ya lo procesamos antes o esta dentro de un cuadradito que &quot;no \nse toca&quot; no lo volvemos a revisar).\nComo se imaginaran hay mejoras a esta tecnica que incluyen tambien renderizar \nel pixel en el medio de cada cuadradito, pero por ahora no la quiero \ncomplicar.\nDe esta menra se obtienen imagenes de mucha nitidez con un ahorro muy\nconsiderable de CPU.\n\n-Como habran visto el en demo, don Silverman pareciera que todavia no empezo a \ntrabajar en tecnicas para interpolar los voxels cuando estan muy cerca de la \ncamara, asi que se van a encontrar con tamanios cuadradotes, pero \ndefinitivamente este es otro aspecto interesante del area.\n\n-Tambien quiero aclarar que si esta tecnica es bien usada, se puede\nllevar lo mas bien con la geometria actual, y mezclar esto con\npoligonos es solo cuestion de compartir un Zbuffer.\n\nBueno, fue un gusto poder compartir esto con ustedes, y espero que les sea de \nalguna utilidad. En mi opinion esto puede llegar a ser una verdadera\nrevolucion si se logra llegar a correr en el hardware 3D. Saludos a todos!\n\nJuan Linietsky - reduz / CODENIX.\n--=-=\nhttp://www.codenix.com\n\n\n\n\n\n\n\n"}}